// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_user_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_user_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_user_2eproto;
namespace UserProto {
class AddFriendRequest;
struct AddFriendRequestDefaultTypeInternal;
extern AddFriendRequestDefaultTypeInternal _AddFriendRequest_default_instance_;
class AddFriendResponse;
struct AddFriendResponseDefaultTypeInternal;
extern AddFriendResponseDefaultTypeInternal _AddFriendResponse_default_instance_;
class AddGroupRequest;
struct AddGroupRequestDefaultTypeInternal;
extern AddGroupRequestDefaultTypeInternal _AddGroupRequest_default_instance_;
class AddGroupResponse;
struct AddGroupResponseDefaultTypeInternal;
extern AddGroupResponseDefaultTypeInternal _AddGroupResponse_default_instance_;
class BroadcastMessage;
struct BroadcastMessageDefaultTypeInternal;
extern BroadcastMessageDefaultTypeInternal _BroadcastMessage_default_instance_;
class CreateGroupRequest;
struct CreateGroupRequestDefaultTypeInternal;
extern CreateGroupRequestDefaultTypeInternal _CreateGroupRequest_default_instance_;
class CreateGroupResponse;
struct CreateGroupResponseDefaultTypeInternal;
extern CreateGroupResponseDefaultTypeInternal _CreateGroupResponse_default_instance_;
class DeleteFriendRequest;
struct DeleteFriendRequestDefaultTypeInternal;
extern DeleteFriendRequestDefaultTypeInternal _DeleteFriendRequest_default_instance_;
class DeleteFriendResponse;
struct DeleteFriendResponseDefaultTypeInternal;
extern DeleteFriendResponseDefaultTypeInternal _DeleteFriendResponse_default_instance_;
class DeleteGroupRequest;
struct DeleteGroupRequestDefaultTypeInternal;
extern DeleteGroupRequestDefaultTypeInternal _DeleteGroupRequest_default_instance_;
class DeleteGroupResponse;
struct DeleteGroupResponseDefaultTypeInternal;
extern DeleteGroupResponseDefaultTypeInternal _DeleteGroupResponse_default_instance_;
class FriendChatRequest;
struct FriendChatRequestDefaultTypeInternal;
extern FriendChatRequestDefaultTypeInternal _FriendChatRequest_default_instance_;
class FriendChatResponse;
struct FriendChatResponseDefaultTypeInternal;
extern FriendChatResponseDefaultTypeInternal _FriendChatResponse_default_instance_;
class FriendList;
struct FriendListDefaultTypeInternal;
extern FriendListDefaultTypeInternal _FriendList_default_instance_;
class FriendUser;
struct FriendUserDefaultTypeInternal;
extern FriendUserDefaultTypeInternal _FriendUser_default_instance_;
class Group;
struct GroupDefaultTypeInternal;
extern GroupDefaultTypeInternal _Group_default_instance_;
class GroupChatRequest;
struct GroupChatRequestDefaultTypeInternal;
extern GroupChatRequestDefaultTypeInternal _GroupChatRequest_default_instance_;
class GroupChatResponse;
struct GroupChatResponseDefaultTypeInternal;
extern GroupChatResponseDefaultTypeInternal _GroupChatResponse_default_instance_;
class GroupList;
struct GroupListDefaultTypeInternal;
extern GroupListDefaultTypeInternal _GroupList_default_instance_;
class GroupMessage;
struct GroupMessageDefaultTypeInternal;
extern GroupMessageDefaultTypeInternal _GroupMessage_default_instance_;
class GroupUser;
struct GroupUserDefaultTypeInternal;
extern GroupUserDefaultTypeInternal _GroupUser_default_instance_;
class GroupUserList;
struct GroupUserListDefaultTypeInternal;
extern GroupUserListDefaultTypeInternal _GroupUserList_default_instance_;
class LoginRequest;
struct LoginRequestDefaultTypeInternal;
extern LoginRequestDefaultTypeInternal _LoginRequest_default_instance_;
class LoginResponse;
struct LoginResponseDefaultTypeInternal;
extern LoginResponseDefaultTypeInternal _LoginResponse_default_instance_;
class LogoutRequest;
struct LogoutRequestDefaultTypeInternal;
extern LogoutRequestDefaultTypeInternal _LogoutRequest_default_instance_;
class LogoutResponse;
struct LogoutResponseDefaultTypeInternal;
extern LogoutResponseDefaultTypeInternal _LogoutResponse_default_instance_;
class Message;
struct MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class OfflineMessageList;
struct OfflineMessageListDefaultTypeInternal;
extern OfflineMessageListDefaultTypeInternal _OfflineMessageList_default_instance_;
class QuitGroupRequest;
struct QuitGroupRequestDefaultTypeInternal;
extern QuitGroupRequestDefaultTypeInternal _QuitGroupRequest_default_instance_;
class QuitGroupResponse;
struct QuitGroupResponseDefaultTypeInternal;
extern QuitGroupResponseDefaultTypeInternal _QuitGroupResponse_default_instance_;
class Receiver;
struct ReceiverDefaultTypeInternal;
extern ReceiverDefaultTypeInternal _Receiver_default_instance_;
class RegisterRequest;
struct RegisterRequestDefaultTypeInternal;
extern RegisterRequestDefaultTypeInternal _RegisterRequest_default_instance_;
class RegisterResponse;
struct RegisterResponseDefaultTypeInternal;
extern RegisterResponseDefaultTypeInternal _RegisterResponse_default_instance_;
class Sender;
struct SenderDefaultTypeInternal;
extern SenderDefaultTypeInternal _Sender_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace UserProto
PROTOBUF_NAMESPACE_OPEN
template<> ::UserProto::AddFriendRequest* Arena::CreateMaybeMessage<::UserProto::AddFriendRequest>(Arena*);
template<> ::UserProto::AddFriendResponse* Arena::CreateMaybeMessage<::UserProto::AddFriendResponse>(Arena*);
template<> ::UserProto::AddGroupRequest* Arena::CreateMaybeMessage<::UserProto::AddGroupRequest>(Arena*);
template<> ::UserProto::AddGroupResponse* Arena::CreateMaybeMessage<::UserProto::AddGroupResponse>(Arena*);
template<> ::UserProto::BroadcastMessage* Arena::CreateMaybeMessage<::UserProto::BroadcastMessage>(Arena*);
template<> ::UserProto::CreateGroupRequest* Arena::CreateMaybeMessage<::UserProto::CreateGroupRequest>(Arena*);
template<> ::UserProto::CreateGroupResponse* Arena::CreateMaybeMessage<::UserProto::CreateGroupResponse>(Arena*);
template<> ::UserProto::DeleteFriendRequest* Arena::CreateMaybeMessage<::UserProto::DeleteFriendRequest>(Arena*);
template<> ::UserProto::DeleteFriendResponse* Arena::CreateMaybeMessage<::UserProto::DeleteFriendResponse>(Arena*);
template<> ::UserProto::DeleteGroupRequest* Arena::CreateMaybeMessage<::UserProto::DeleteGroupRequest>(Arena*);
template<> ::UserProto::DeleteGroupResponse* Arena::CreateMaybeMessage<::UserProto::DeleteGroupResponse>(Arena*);
template<> ::UserProto::FriendChatRequest* Arena::CreateMaybeMessage<::UserProto::FriendChatRequest>(Arena*);
template<> ::UserProto::FriendChatResponse* Arena::CreateMaybeMessage<::UserProto::FriendChatResponse>(Arena*);
template<> ::UserProto::FriendList* Arena::CreateMaybeMessage<::UserProto::FriendList>(Arena*);
template<> ::UserProto::FriendUser* Arena::CreateMaybeMessage<::UserProto::FriendUser>(Arena*);
template<> ::UserProto::Group* Arena::CreateMaybeMessage<::UserProto::Group>(Arena*);
template<> ::UserProto::GroupChatRequest* Arena::CreateMaybeMessage<::UserProto::GroupChatRequest>(Arena*);
template<> ::UserProto::GroupChatResponse* Arena::CreateMaybeMessage<::UserProto::GroupChatResponse>(Arena*);
template<> ::UserProto::GroupList* Arena::CreateMaybeMessage<::UserProto::GroupList>(Arena*);
template<> ::UserProto::GroupMessage* Arena::CreateMaybeMessage<::UserProto::GroupMessage>(Arena*);
template<> ::UserProto::GroupUser* Arena::CreateMaybeMessage<::UserProto::GroupUser>(Arena*);
template<> ::UserProto::GroupUserList* Arena::CreateMaybeMessage<::UserProto::GroupUserList>(Arena*);
template<> ::UserProto::LoginRequest* Arena::CreateMaybeMessage<::UserProto::LoginRequest>(Arena*);
template<> ::UserProto::LoginResponse* Arena::CreateMaybeMessage<::UserProto::LoginResponse>(Arena*);
template<> ::UserProto::LogoutRequest* Arena::CreateMaybeMessage<::UserProto::LogoutRequest>(Arena*);
template<> ::UserProto::LogoutResponse* Arena::CreateMaybeMessage<::UserProto::LogoutResponse>(Arena*);
template<> ::UserProto::Message* Arena::CreateMaybeMessage<::UserProto::Message>(Arena*);
template<> ::UserProto::OfflineMessageList* Arena::CreateMaybeMessage<::UserProto::OfflineMessageList>(Arena*);
template<> ::UserProto::QuitGroupRequest* Arena::CreateMaybeMessage<::UserProto::QuitGroupRequest>(Arena*);
template<> ::UserProto::QuitGroupResponse* Arena::CreateMaybeMessage<::UserProto::QuitGroupResponse>(Arena*);
template<> ::UserProto::Receiver* Arena::CreateMaybeMessage<::UserProto::Receiver>(Arena*);
template<> ::UserProto::RegisterRequest* Arena::CreateMaybeMessage<::UserProto::RegisterRequest>(Arena*);
template<> ::UserProto::RegisterResponse* Arena::CreateMaybeMessage<::UserProto::RegisterResponse>(Arena*);
template<> ::UserProto::Sender* Arena::CreateMaybeMessage<::UserProto::Sender>(Arena*);
template<> ::UserProto::User* Arena::CreateMaybeMessage<::UserProto::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace UserProto {

enum MessageType : int {
  UNKNOWN = 0,
  FRIEND_CHAT = 1,
  GROUP_CHAT = 2,
  ADD_FRIEND = 3,
  DELETE_FRIEND = 4,
  ADD_GROUP = 5,
  QUIT_GROUP = 6,
  DELETE_GROUP = 7,
  MessageType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  MessageType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool MessageType_IsValid(int value);
constexpr MessageType MessageType_MIN = UNKNOWN;
constexpr MessageType MessageType_MAX = DELETE_GROUP;
constexpr int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* MessageType_descriptor();
template<typename T>
inline const std::string& MessageType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, MessageType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function MessageType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    MessageType_descriptor(), enum_t_value);
}
inline bool MessageType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, MessageType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
// ===================================================================

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit PROTOBUF_CONSTEXPR User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const User& from) {
    User::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kUserStateFieldNumber = 3,
    kUserPasswordFieldNumber = 4,
    kLastOfflineTimeFieldNumber = 5,
    kUserIdFieldNumber = 1,
  };
  // bytes user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bytes user_state = 3;
  void clear_user_state();
  const std::string& user_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_state();
  PROTOBUF_NODISCARD std::string* release_user_state();
  void set_allocated_user_state(std::string* user_state);
  private:
  const std::string& _internal_user_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_state(const std::string& value);
  std::string* _internal_mutable_user_state();
  public:

  // bytes user_password = 4;
  void clear_user_password();
  const std::string& user_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_password();
  PROTOBUF_NODISCARD std::string* release_user_password();
  void set_allocated_user_password(std::string* user_password);
  private:
  const std::string& _internal_user_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_password(const std::string& value);
  std::string* _internal_mutable_user_password();
  public:

  // string last_offline_time = 5;
  void clear_last_offline_time();
  const std::string& last_offline_time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_last_offline_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_last_offline_time();
  PROTOBUF_NODISCARD std::string* release_last_offline_time();
  void set_allocated_last_offline_time(std::string* last_offline_time);
  private:
  const std::string& _internal_last_offline_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_last_offline_time(const std::string& value);
  std::string* _internal_mutable_last_offline_time();
  public:

  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_password_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr last_offline_time_;
    int32_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class FriendUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.FriendUser) */ {
 public:
  inline FriendUser() : FriendUser(nullptr) {}
  ~FriendUser() override;
  explicit PROTOBUF_CONSTEXPR FriendUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendUser(const FriendUser& from);
  FriendUser(FriendUser&& from) noexcept
    : FriendUser() {
    *this = ::std::move(from);
  }

  inline FriendUser& operator=(const FriendUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendUser& operator=(FriendUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendUser* internal_default_instance() {
    return reinterpret_cast<const FriendUser*>(
               &_FriendUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(FriendUser& a, FriendUser& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendUser& from) {
    FriendUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.FriendUser";
  }
  protected:
  explicit FriendUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendNameFieldNumber = 2,
    kFriendStateFieldNumber = 3,
    kFriendIdFieldNumber = 1,
  };
  // bytes friend_name = 2;
  void clear_friend_name();
  const std::string& friend_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_friend_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_friend_name();
  PROTOBUF_NODISCARD std::string* release_friend_name();
  void set_allocated_friend_name(std::string* friend_name);
  private:
  const std::string& _internal_friend_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friend_name(const std::string& value);
  std::string* _internal_mutable_friend_name();
  public:

  // bytes friend_state = 3;
  void clear_friend_state();
  const std::string& friend_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_friend_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_friend_state();
  PROTOBUF_NODISCARD std::string* release_friend_state();
  void set_allocated_friend_state(std::string* friend_state);
  private:
  const std::string& _internal_friend_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_friend_state(const std::string& value);
  std::string* _internal_mutable_friend_state();
  public:

  // int32 friend_id = 1;
  void clear_friend_id();
  int32_t friend_id() const;
  void set_friend_id(int32_t value);
  private:
  int32_t _internal_friend_id() const;
  void _internal_set_friend_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.FriendUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friend_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr friend_state_;
    int32_t friend_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class FriendList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.FriendList) */ {
 public:
  inline FriendList() : FriendList(nullptr) {}
  ~FriendList() override;
  explicit PROTOBUF_CONSTEXPR FriendList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendList(const FriendList& from);
  FriendList(FriendList&& from) noexcept
    : FriendList() {
    *this = ::std::move(from);
  }

  inline FriendList& operator=(const FriendList& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendList& operator=(FriendList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendList& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendList* internal_default_instance() {
    return reinterpret_cast<const FriendList*>(
               &_FriendList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(FriendList& a, FriendList& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendList& from) {
    FriendList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.FriendList";
  }
  protected:
  explicit FriendList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendUsersFieldNumber = 1,
  };
  // repeated .UserProto.FriendUser friend_users = 1;
  int friend_users_size() const;
  private:
  int _internal_friend_users_size() const;
  public:
  void clear_friend_users();
  ::UserProto::FriendUser* mutable_friend_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::FriendUser >*
      mutable_friend_users();
  private:
  const ::UserProto::FriendUser& _internal_friend_users(int index) const;
  ::UserProto::FriendUser* _internal_add_friend_users();
  public:
  const ::UserProto::FriendUser& friend_users(int index) const;
  ::UserProto::FriendUser* add_friend_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::FriendUser >&
      friend_users() const;

  // @@protoc_insertion_point(class_scope:UserProto.FriendList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::FriendUser > friend_users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GroupUser final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.GroupUser) */ {
 public:
  inline GroupUser() : GroupUser(nullptr) {}
  ~GroupUser() override;
  explicit PROTOBUF_CONSTEXPR GroupUser(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupUser(const GroupUser& from);
  GroupUser(GroupUser&& from) noexcept
    : GroupUser() {
    *this = ::std::move(from);
  }

  inline GroupUser& operator=(const GroupUser& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupUser& operator=(GroupUser&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupUser& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupUser* internal_default_instance() {
    return reinterpret_cast<const GroupUser*>(
               &_GroupUser_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GroupUser& a, GroupUser& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupUser* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupUser* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupUser* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupUser>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupUser& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupUser& from) {
    GroupUser::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupUser* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.GroupUser";
  }
  protected:
  explicit GroupUser(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kUserStateFieldNumber = 3,
    kUserRoleFieldNumber = 4,
    kUserIdFieldNumber = 1,
  };
  // bytes user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bytes user_state = 3;
  void clear_user_state();
  const std::string& user_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_state();
  PROTOBUF_NODISCARD std::string* release_user_state();
  void set_allocated_user_state(std::string* user_state);
  private:
  const std::string& _internal_user_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_state(const std::string& value);
  std::string* _internal_mutable_user_state();
  public:

  // bytes user_role = 4;
  void clear_user_role();
  const std::string& user_role() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_role(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_role();
  PROTOBUF_NODISCARD std::string* release_user_role();
  void set_allocated_user_role(std::string* user_role);
  private:
  const std::string& _internal_user_role() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_role(const std::string& value);
  std::string* _internal_mutable_user_role();
  public:

  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.GroupUser)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_state_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_role_;
    int32_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class Group final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.Group) */ {
 public:
  inline Group() : Group(nullptr) {}
  ~Group() override;
  explicit PROTOBUF_CONSTEXPR Group(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Group(const Group& from);
  Group(Group&& from) noexcept
    : Group() {
    *this = ::std::move(from);
  }

  inline Group& operator=(const Group& from) {
    CopyFrom(from);
    return *this;
  }
  inline Group& operator=(Group&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Group& default_instance() {
    return *internal_default_instance();
  }
  static inline const Group* internal_default_instance() {
    return reinterpret_cast<const Group*>(
               &_Group_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(Group& a, Group& b) {
    a.Swap(&b);
  }
  inline void Swap(Group* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Group* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Group* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Group>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Group& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Group& from) {
    Group::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Group* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.Group";
  }
  protected:
  explicit Group(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupNameFieldNumber = 2,
    kGroupDescriptionFieldNumber = 3,
    kGroupUserListFieldNumber = 4,
    kGroupIdFieldNumber = 1,
  };
  // bytes group_name = 2;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // bytes group_description = 3;
  void clear_group_description();
  const std::string& group_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_description();
  PROTOBUF_NODISCARD std::string* release_group_description();
  void set_allocated_group_description(std::string* group_description);
  private:
  const std::string& _internal_group_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_description(const std::string& value);
  std::string* _internal_mutable_group_description();
  public:

  // .UserProto.GroupUserList group_user_list = 4;
  bool has_group_user_list() const;
  private:
  bool _internal_has_group_user_list() const;
  public:
  void clear_group_user_list();
  const ::UserProto::GroupUserList& group_user_list() const;
  PROTOBUF_NODISCARD ::UserProto::GroupUserList* release_group_user_list();
  ::UserProto::GroupUserList* mutable_group_user_list();
  void set_allocated_group_user_list(::UserProto::GroupUserList* group_user_list);
  private:
  const ::UserProto::GroupUserList& _internal_group_user_list() const;
  ::UserProto::GroupUserList* _internal_mutable_group_user_list();
  public:
  void unsafe_arena_set_allocated_group_user_list(
      ::UserProto::GroupUserList* group_user_list);
  ::UserProto::GroupUserList* unsafe_arena_release_group_user_list();

  // int32 group_id = 1;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.Group)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_description_;
    ::UserProto::GroupUserList* group_user_list_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GroupList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.GroupList) */ {
 public:
  inline GroupList() : GroupList(nullptr) {}
  ~GroupList() override;
  explicit PROTOBUF_CONSTEXPR GroupList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupList(const GroupList& from);
  GroupList(GroupList&& from) noexcept
    : GroupList() {
    *this = ::std::move(from);
  }

  inline GroupList& operator=(const GroupList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupList& operator=(GroupList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupList* internal_default_instance() {
    return reinterpret_cast<const GroupList*>(
               &_GroupList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GroupList& a, GroupList& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupList& from) {
    GroupList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.GroupList";
  }
  protected:
  explicit GroupList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupsFieldNumber = 1,
  };
  // repeated .UserProto.Group groups = 1;
  int groups_size() const;
  private:
  int _internal_groups_size() const;
  public:
  void clear_groups();
  ::UserProto::Group* mutable_groups(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Group >*
      mutable_groups();
  private:
  const ::UserProto::Group& _internal_groups(int index) const;
  ::UserProto::Group* _internal_add_groups();
  public:
  const ::UserProto::Group& groups(int index) const;
  ::UserProto::Group* add_groups();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Group >&
      groups() const;

  // @@protoc_insertion_point(class_scope:UserProto.GroupList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Group > groups_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GroupUserList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.GroupUserList) */ {
 public:
  inline GroupUserList() : GroupUserList(nullptr) {}
  ~GroupUserList() override;
  explicit PROTOBUF_CONSTEXPR GroupUserList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupUserList(const GroupUserList& from);
  GroupUserList(GroupUserList&& from) noexcept
    : GroupUserList() {
    *this = ::std::move(from);
  }

  inline GroupUserList& operator=(const GroupUserList& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupUserList& operator=(GroupUserList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupUserList& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupUserList* internal_default_instance() {
    return reinterpret_cast<const GroupUserList*>(
               &_GroupUserList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(GroupUserList& a, GroupUserList& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupUserList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupUserList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupUserList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupUserList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupUserList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupUserList& from) {
    GroupUserList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupUserList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.GroupUserList";
  }
  protected:
  explicit GroupUserList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupUsersFieldNumber = 1,
  };
  // repeated .UserProto.GroupUser group_users = 1;
  int group_users_size() const;
  private:
  int _internal_group_users_size() const;
  public:
  void clear_group_users();
  ::UserProto::GroupUser* mutable_group_users(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::GroupUser >*
      mutable_group_users();
  private:
  const ::UserProto::GroupUser& _internal_group_users(int index) const;
  ::UserProto::GroupUser* _internal_add_group_users();
  public:
  const ::UserProto::GroupUser& group_users(int index) const;
  ::UserProto::GroupUser* add_group_users();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::GroupUser >&
      group_users() const;

  // @@protoc_insertion_point(class_scope:UserProto.GroupUserList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::GroupUser > group_users_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class BroadcastMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.BroadcastMessage) */ {
 public:
  inline BroadcastMessage() : BroadcastMessage(nullptr) {}
  ~BroadcastMessage() override;
  explicit PROTOBUF_CONSTEXPR BroadcastMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BroadcastMessage(const BroadcastMessage& from);
  BroadcastMessage(BroadcastMessage&& from) noexcept
    : BroadcastMessage() {
    *this = ::std::move(from);
  }

  inline BroadcastMessage& operator=(const BroadcastMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline BroadcastMessage& operator=(BroadcastMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BroadcastMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const BroadcastMessage* internal_default_instance() {
    return reinterpret_cast<const BroadcastMessage*>(
               &_BroadcastMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(BroadcastMessage& a, BroadcastMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(BroadcastMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BroadcastMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  BroadcastMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<BroadcastMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BroadcastMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const BroadcastMessage& from) {
    BroadcastMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BroadcastMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.BroadcastMessage";
  }
  protected:
  explicit BroadcastMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kMessageTypeFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .UserProto.MessageType message_type = 1;
  void clear_message_type();
  ::UserProto::MessageType message_type() const;
  void set_message_type(::UserProto::MessageType value);
  private:
  ::UserProto::MessageType _internal_message_type() const;
  void _internal_set_message_type(::UserProto::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.BroadcastMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    int message_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class Message final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.Message) */ {
 public:
  inline Message() : Message(nullptr) {}
  ~Message() override;
  explicit PROTOBUF_CONSTEXPR Message(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Message(const Message& from);
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  inline Message& operator=(Message&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Message& default_instance() {
    return *internal_default_instance();
  }
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }
  inline void Swap(Message* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Message* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Message* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Message& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Message& from) {
    Message::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.Message";
  }
  protected:
  explicit Message(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeFieldNumber = 4,
    kContentFieldNumber = 5,
    kSenderFieldNumber = 2,
    kReceiverFieldNumber = 3,
    kMessageTypeFieldNumber = 1,
  };
  // string time = 4;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // string content = 5;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .UserProto.Sender sender = 2;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::UserProto::Sender& sender() const;
  PROTOBUF_NODISCARD ::UserProto::Sender* release_sender();
  ::UserProto::Sender* mutable_sender();
  void set_allocated_sender(::UserProto::Sender* sender);
  private:
  const ::UserProto::Sender& _internal_sender() const;
  ::UserProto::Sender* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::UserProto::Sender* sender);
  ::UserProto::Sender* unsafe_arena_release_sender();

  // .UserProto.Receiver receiver = 3;
  bool has_receiver() const;
  private:
  bool _internal_has_receiver() const;
  public:
  void clear_receiver();
  const ::UserProto::Receiver& receiver() const;
  PROTOBUF_NODISCARD ::UserProto::Receiver* release_receiver();
  ::UserProto::Receiver* mutable_receiver();
  void set_allocated_receiver(::UserProto::Receiver* receiver);
  private:
  const ::UserProto::Receiver& _internal_receiver() const;
  ::UserProto::Receiver* _internal_mutable_receiver();
  public:
  void unsafe_arena_set_allocated_receiver(
      ::UserProto::Receiver* receiver);
  ::UserProto::Receiver* unsafe_arena_release_receiver();

  // .UserProto.MessageType message_type = 1;
  void clear_message_type();
  ::UserProto::MessageType message_type() const;
  void set_message_type(::UserProto::MessageType value);
  private:
  ::UserProto::MessageType _internal_message_type() const;
  void _internal_set_message_type(::UserProto::MessageType value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.Message)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::UserProto::Sender* sender_;
    ::UserProto::Receiver* receiver_;
    int message_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class Sender final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.Sender) */ {
 public:
  inline Sender() : Sender(nullptr) {}
  ~Sender() override;
  explicit PROTOBUF_CONSTEXPR Sender(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Sender(const Sender& from);
  Sender(Sender&& from) noexcept
    : Sender() {
    *this = ::std::move(from);
  }

  inline Sender& operator=(const Sender& from) {
    CopyFrom(from);
    return *this;
  }
  inline Sender& operator=(Sender&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Sender& default_instance() {
    return *internal_default_instance();
  }
  static inline const Sender* internal_default_instance() {
    return reinterpret_cast<const Sender*>(
               &_Sender_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(Sender& a, Sender& b) {
    a.Swap(&b);
  }
  inline void Swap(Sender* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Sender* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Sender* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Sender>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Sender& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Sender& from) {
    Sender::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Sender* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.Sender";
  }
  protected:
  explicit Sender(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kGroupNameFieldNumber = 4,
    kUserIdFieldNumber = 1,
    kGroupIdFieldNumber = 3,
  };
  // bytes user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bytes group_name = 4;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // int32 group_id = 3;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.Sender)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    int32_t user_id_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class Receiver final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.Receiver) */ {
 public:
  inline Receiver() : Receiver(nullptr) {}
  ~Receiver() override;
  explicit PROTOBUF_CONSTEXPR Receiver(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Receiver(const Receiver& from);
  Receiver(Receiver&& from) noexcept
    : Receiver() {
    *this = ::std::move(from);
  }

  inline Receiver& operator=(const Receiver& from) {
    CopyFrom(from);
    return *this;
  }
  inline Receiver& operator=(Receiver&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Receiver& default_instance() {
    return *internal_default_instance();
  }
  static inline const Receiver* internal_default_instance() {
    return reinterpret_cast<const Receiver*>(
               &_Receiver_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(Receiver& a, Receiver& b) {
    a.Swap(&b);
  }
  inline void Swap(Receiver* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Receiver* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Receiver* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Receiver>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Receiver& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const Receiver& from) {
    Receiver::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Receiver* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.Receiver";
  }
  protected:
  explicit Receiver(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kGroupNameFieldNumber = 4,
    kUserIdFieldNumber = 1,
    kGroupIdFieldNumber = 3,
  };
  // bytes user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bytes group_name = 4;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // int32 group_id = 3;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.Receiver)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    int32_t user_id_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GroupMessage final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.GroupMessage) */ {
 public:
  inline GroupMessage() : GroupMessage(nullptr) {}
  ~GroupMessage() override;
  explicit PROTOBUF_CONSTEXPR GroupMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupMessage(const GroupMessage& from);
  GroupMessage(GroupMessage&& from) noexcept
    : GroupMessage() {
    *this = ::std::move(from);
  }

  inline GroupMessage& operator=(const GroupMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupMessage& operator=(GroupMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupMessage* internal_default_instance() {
    return reinterpret_cast<const GroupMessage*>(
               &_GroupMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GroupMessage& a, GroupMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupMessage>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupMessage& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupMessage& from) {
    GroupMessage::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.GroupMessage";
  }
  protected:
  explicit GroupMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 2,
    kGroupUserListFieldNumber = 1,
  };
  // bytes content = 2;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // .UserProto.GroupUserList group_user_list = 1;
  bool has_group_user_list() const;
  private:
  bool _internal_has_group_user_list() const;
  public:
  void clear_group_user_list();
  const ::UserProto::GroupUserList& group_user_list() const;
  PROTOBUF_NODISCARD ::UserProto::GroupUserList* release_group_user_list();
  ::UserProto::GroupUserList* mutable_group_user_list();
  void set_allocated_group_user_list(::UserProto::GroupUserList* group_user_list);
  private:
  const ::UserProto::GroupUserList& _internal_group_user_list() const;
  ::UserProto::GroupUserList* _internal_mutable_group_user_list();
  public:
  void unsafe_arena_set_allocated_group_user_list(
      ::UserProto::GroupUserList* group_user_list);
  ::UserProto::GroupUserList* unsafe_arena_release_group_user_list();

  // @@protoc_insertion_point(class_scope:UserProto.GroupMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::UserProto::GroupUserList* group_user_list_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class OfflineMessageList final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.OfflineMessageList) */ {
 public:
  inline OfflineMessageList() : OfflineMessageList(nullptr) {}
  ~OfflineMessageList() override;
  explicit PROTOBUF_CONSTEXPR OfflineMessageList(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OfflineMessageList(const OfflineMessageList& from);
  OfflineMessageList(OfflineMessageList&& from) noexcept
    : OfflineMessageList() {
    *this = ::std::move(from);
  }

  inline OfflineMessageList& operator=(const OfflineMessageList& from) {
    CopyFrom(from);
    return *this;
  }
  inline OfflineMessageList& operator=(OfflineMessageList&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OfflineMessageList& default_instance() {
    return *internal_default_instance();
  }
  static inline const OfflineMessageList* internal_default_instance() {
    return reinterpret_cast<const OfflineMessageList*>(
               &_OfflineMessageList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(OfflineMessageList& a, OfflineMessageList& b) {
    a.Swap(&b);
  }
  inline void Swap(OfflineMessageList* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OfflineMessageList* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  OfflineMessageList* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<OfflineMessageList>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OfflineMessageList& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const OfflineMessageList& from) {
    OfflineMessageList::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OfflineMessageList* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.OfflineMessageList";
  }
  protected:
  explicit OfflineMessageList(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMessagesFieldNumber = 1,
  };
  // repeated .UserProto.Message messages = 1;
  int messages_size() const;
  private:
  int _internal_messages_size() const;
  public:
  void clear_messages();
  ::UserProto::Message* mutable_messages(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Message >*
      mutable_messages();
  private:
  const ::UserProto::Message& _internal_messages(int index) const;
  ::UserProto::Message* _internal_add_messages();
  public:
  const ::UserProto::Message& messages(int index) const;
  ::UserProto::Message* add_messages();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Message >&
      messages() const;

  // @@protoc_insertion_point(class_scope:UserProto.OfflineMessageList)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Message > messages_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class LoginRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.LoginRequest) */ {
 public:
  inline LoginRequest() : LoginRequest(nullptr) {}
  ~LoginRequest() override;
  explicit PROTOBUF_CONSTEXPR LoginRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginRequest(const LoginRequest& from);
  LoginRequest(LoginRequest&& from) noexcept
    : LoginRequest() {
    *this = ::std::move(from);
  }

  inline LoginRequest& operator=(const LoginRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginRequest& operator=(LoginRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginRequest* internal_default_instance() {
    return reinterpret_cast<const LoginRequest*>(
               &_LoginRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(LoginRequest& a, LoginRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginRequest& from) {
    LoginRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.LoginRequest";
  }
  protected:
  explicit LoginRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserPasswordFieldNumber = 2,
    kUserIdFieldNumber = 1,
  };
  // bytes user_password = 2;
  void clear_user_password();
  const std::string& user_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_password();
  PROTOBUF_NODISCARD std::string* release_user_password();
  void set_allocated_user_password(std::string* user_password);
  private:
  const std::string& _internal_user_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_password(const std::string& value);
  std::string* _internal_mutable_user_password();
  public:

  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.LoginRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_password_;
    int32_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class LoginResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.LoginResponse) */ {
 public:
  inline LoginResponse() : LoginResponse(nullptr) {}
  ~LoginResponse() override;
  explicit PROTOBUF_CONSTEXPR LoginResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LoginResponse(const LoginResponse& from);
  LoginResponse(LoginResponse&& from) noexcept
    : LoginResponse() {
    *this = ::std::move(from);
  }

  inline LoginResponse& operator=(const LoginResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LoginResponse& operator=(LoginResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LoginResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LoginResponse* internal_default_instance() {
    return reinterpret_cast<const LoginResponse*>(
               &_LoginResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(LoginResponse& a, LoginResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LoginResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LoginResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LoginResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LoginResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LoginResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LoginResponse& from) {
    LoginResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LoginResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.LoginResponse";
  }
  protected:
  explicit LoginResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserFieldNumber = 2,
    kFriendListFieldNumber = 3,
    kGroupListFieldNumber = 4,
    kOfflineMessageListFieldNumber = 5,
    kErrorCodeFieldNumber = 1,
  };
  // .UserProto.User user = 2;
  bool has_user() const;
  private:
  bool _internal_has_user() const;
  public:
  void clear_user();
  const ::UserProto::User& user() const;
  PROTOBUF_NODISCARD ::UserProto::User* release_user();
  ::UserProto::User* mutable_user();
  void set_allocated_user(::UserProto::User* user);
  private:
  const ::UserProto::User& _internal_user() const;
  ::UserProto::User* _internal_mutable_user();
  public:
  void unsafe_arena_set_allocated_user(
      ::UserProto::User* user);
  ::UserProto::User* unsafe_arena_release_user();

  // .UserProto.FriendList friend_list = 3;
  bool has_friend_list() const;
  private:
  bool _internal_has_friend_list() const;
  public:
  void clear_friend_list();
  const ::UserProto::FriendList& friend_list() const;
  PROTOBUF_NODISCARD ::UserProto::FriendList* release_friend_list();
  ::UserProto::FriendList* mutable_friend_list();
  void set_allocated_friend_list(::UserProto::FriendList* friend_list);
  private:
  const ::UserProto::FriendList& _internal_friend_list() const;
  ::UserProto::FriendList* _internal_mutable_friend_list();
  public:
  void unsafe_arena_set_allocated_friend_list(
      ::UserProto::FriendList* friend_list);
  ::UserProto::FriendList* unsafe_arena_release_friend_list();

  // .UserProto.GroupList group_list = 4;
  bool has_group_list() const;
  private:
  bool _internal_has_group_list() const;
  public:
  void clear_group_list();
  const ::UserProto::GroupList& group_list() const;
  PROTOBUF_NODISCARD ::UserProto::GroupList* release_group_list();
  ::UserProto::GroupList* mutable_group_list();
  void set_allocated_group_list(::UserProto::GroupList* group_list);
  private:
  const ::UserProto::GroupList& _internal_group_list() const;
  ::UserProto::GroupList* _internal_mutable_group_list();
  public:
  void unsafe_arena_set_allocated_group_list(
      ::UserProto::GroupList* group_list);
  ::UserProto::GroupList* unsafe_arena_release_group_list();

  // .UserProto.OfflineMessageList offline_message_list = 5;
  bool has_offline_message_list() const;
  private:
  bool _internal_has_offline_message_list() const;
  public:
  void clear_offline_message_list();
  const ::UserProto::OfflineMessageList& offline_message_list() const;
  PROTOBUF_NODISCARD ::UserProto::OfflineMessageList* release_offline_message_list();
  ::UserProto::OfflineMessageList* mutable_offline_message_list();
  void set_allocated_offline_message_list(::UserProto::OfflineMessageList* offline_message_list);
  private:
  const ::UserProto::OfflineMessageList& _internal_offline_message_list() const;
  ::UserProto::OfflineMessageList* _internal_mutable_offline_message_list();
  public:
  void unsafe_arena_set_allocated_offline_message_list(
      ::UserProto::OfflineMessageList* offline_message_list);
  ::UserProto::OfflineMessageList* unsafe_arena_release_offline_message_list();

  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.LoginResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::UserProto::User* user_;
    ::UserProto::FriendList* friend_list_;
    ::UserProto::GroupList* group_list_;
    ::UserProto::OfflineMessageList* offline_message_list_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class LogoutRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.LogoutRequest) */ {
 public:
  inline LogoutRequest() : LogoutRequest(nullptr) {}
  ~LogoutRequest() override;
  explicit PROTOBUF_CONSTEXPR LogoutRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutRequest(const LogoutRequest& from);
  LogoutRequest(LogoutRequest&& from) noexcept
    : LogoutRequest() {
    *this = ::std::move(from);
  }

  inline LogoutRequest& operator=(const LogoutRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutRequest& operator=(LogoutRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutRequest* internal_default_instance() {
    return reinterpret_cast<const LogoutRequest*>(
               &_LogoutRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(LogoutRequest& a, LogoutRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutRequest& from) {
    LogoutRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.LogoutRequest";
  }
  protected:
  explicit LogoutRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
  };
  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.LogoutRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class LogoutResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.LogoutResponse) */ {
 public:
  inline LogoutResponse() : LogoutResponse(nullptr) {}
  ~LogoutResponse() override;
  explicit PROTOBUF_CONSTEXPR LogoutResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LogoutResponse(const LogoutResponse& from);
  LogoutResponse(LogoutResponse&& from) noexcept
    : LogoutResponse() {
    *this = ::std::move(from);
  }

  inline LogoutResponse& operator=(const LogoutResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline LogoutResponse& operator=(LogoutResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LogoutResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const LogoutResponse* internal_default_instance() {
    return reinterpret_cast<const LogoutResponse*>(
               &_LogoutResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(LogoutResponse& a, LogoutResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(LogoutResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LogoutResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  LogoutResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<LogoutResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LogoutResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const LogoutResponse& from) {
    LogoutResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LogoutResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.LogoutResponse";
  }
  protected:
  explicit LogoutResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.LogoutResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class RegisterRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.RegisterRequest) */ {
 public:
  inline RegisterRequest() : RegisterRequest(nullptr) {}
  ~RegisterRequest() override;
  explicit PROTOBUF_CONSTEXPR RegisterRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterRequest(const RegisterRequest& from);
  RegisterRequest(RegisterRequest&& from) noexcept
    : RegisterRequest() {
    *this = ::std::move(from);
  }

  inline RegisterRequest& operator=(const RegisterRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterRequest& operator=(RegisterRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterRequest* internal_default_instance() {
    return reinterpret_cast<const RegisterRequest*>(
               &_RegisterRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(RegisterRequest& a, RegisterRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterRequest& from) {
    RegisterRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.RegisterRequest";
  }
  protected:
  explicit RegisterRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserNameFieldNumber = 2,
    kUserPasswordFieldNumber = 3,
  };
  // bytes user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_NODISCARD std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // bytes user_password = 3;
  void clear_user_password();
  const std::string& user_password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_password();
  PROTOBUF_NODISCARD std::string* release_user_password();
  void set_allocated_user_password(std::string* user_password);
  private:
  const std::string& _internal_user_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_password(const std::string& value);
  std::string* _internal_mutable_user_password();
  public:

  // @@protoc_insertion_point(class_scope:UserProto.RegisterRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_password_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class RegisterResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.RegisterResponse) */ {
 public:
  inline RegisterResponse() : RegisterResponse(nullptr) {}
  ~RegisterResponse() override;
  explicit PROTOBUF_CONSTEXPR RegisterResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegisterResponse(const RegisterResponse& from);
  RegisterResponse(RegisterResponse&& from) noexcept
    : RegisterResponse() {
    *this = ::std::move(from);
  }

  inline RegisterResponse& operator=(const RegisterResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegisterResponse& operator=(RegisterResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegisterResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegisterResponse* internal_default_instance() {
    return reinterpret_cast<const RegisterResponse*>(
               &_RegisterResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(RegisterResponse& a, RegisterResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegisterResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegisterResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  RegisterResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<RegisterResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegisterResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const RegisterResponse& from) {
    RegisterResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegisterResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.RegisterResponse";
  }
  protected:
  explicit RegisterResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kUserIdFieldNumber = 2,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // int32 user_id = 2;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.RegisterResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    int32_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class AddFriendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.AddFriendRequest) */ {
 public:
  inline AddFriendRequest() : AddFriendRequest(nullptr) {}
  ~AddFriendRequest() override;
  explicit PROTOBUF_CONSTEXPR AddFriendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFriendRequest(const AddFriendRequest& from);
  AddFriendRequest(AddFriendRequest&& from) noexcept
    : AddFriendRequest() {
    *this = ::std::move(from);
  }

  inline AddFriendRequest& operator=(const AddFriendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFriendRequest& operator=(AddFriendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFriendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFriendRequest* internal_default_instance() {
    return reinterpret_cast<const AddFriendRequest*>(
               &_AddFriendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(AddFriendRequest& a, AddFriendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFriendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFriendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFriendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFriendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFriendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddFriendRequest& from) {
    AddFriendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.AddFriendRequest";
  }
  protected:
  explicit AddFriendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFrinedIdFieldNumber = 2,
  };
  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // int32 frined_id = 2;
  void clear_frined_id();
  int32_t frined_id() const;
  void set_frined_id(int32_t value);
  private:
  int32_t _internal_frined_id() const;
  void _internal_set_frined_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.AddFriendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t user_id_;
    int32_t frined_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class AddFriendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.AddFriendResponse) */ {
 public:
  inline AddFriendResponse() : AddFriendResponse(nullptr) {}
  ~AddFriendResponse() override;
  explicit PROTOBUF_CONSTEXPR AddFriendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddFriendResponse(const AddFriendResponse& from);
  AddFriendResponse(AddFriendResponse&& from) noexcept
    : AddFriendResponse() {
    *this = ::std::move(from);
  }

  inline AddFriendResponse& operator=(const AddFriendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddFriendResponse& operator=(AddFriendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddFriendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddFriendResponse* internal_default_instance() {
    return reinterpret_cast<const AddFriendResponse*>(
               &_AddFriendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(AddFriendResponse& a, AddFriendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddFriendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddFriendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddFriendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddFriendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddFriendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddFriendResponse& from) {
    AddFriendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddFriendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.AddFriendResponse";
  }
  protected:
  explicit AddFriendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFriendUserFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // .UserProto.FriendUser friend_user = 2;
  bool has_friend_user() const;
  private:
  bool _internal_has_friend_user() const;
  public:
  void clear_friend_user();
  const ::UserProto::FriendUser& friend_user() const;
  PROTOBUF_NODISCARD ::UserProto::FriendUser* release_friend_user();
  ::UserProto::FriendUser* mutable_friend_user();
  void set_allocated_friend_user(::UserProto::FriendUser* friend_user);
  private:
  const ::UserProto::FriendUser& _internal_friend_user() const;
  ::UserProto::FriendUser* _internal_mutable_friend_user();
  public:
  void unsafe_arena_set_allocated_friend_user(
      ::UserProto::FriendUser* friend_user);
  ::UserProto::FriendUser* unsafe_arena_release_friend_user();

  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.AddFriendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::UserProto::FriendUser* friend_user_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class DeleteFriendRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.DeleteFriendRequest) */ {
 public:
  inline DeleteFriendRequest() : DeleteFriendRequest(nullptr) {}
  ~DeleteFriendRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteFriendRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFriendRequest(const DeleteFriendRequest& from);
  DeleteFriendRequest(DeleteFriendRequest&& from) noexcept
    : DeleteFriendRequest() {
    *this = ::std::move(from);
  }

  inline DeleteFriendRequest& operator=(const DeleteFriendRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFriendRequest& operator=(DeleteFriendRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFriendRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFriendRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteFriendRequest*>(
               &_DeleteFriendRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(DeleteFriendRequest& a, DeleteFriendRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFriendRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFriendRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFriendRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFriendRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFriendRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFriendRequest& from) {
    DeleteFriendRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFriendRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.DeleteFriendRequest";
  }
  protected:
  explicit DeleteFriendRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kFrinedIdFieldNumber = 2,
  };
  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // int32 frined_id = 2;
  void clear_frined_id();
  int32_t frined_id() const;
  void set_frined_id(int32_t value);
  private:
  int32_t _internal_frined_id() const;
  void _internal_set_frined_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.DeleteFriendRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t user_id_;
    int32_t frined_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class DeleteFriendResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.DeleteFriendResponse) */ {
 public:
  inline DeleteFriendResponse() : DeleteFriendResponse(nullptr) {}
  ~DeleteFriendResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteFriendResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteFriendResponse(const DeleteFriendResponse& from);
  DeleteFriendResponse(DeleteFriendResponse&& from) noexcept
    : DeleteFriendResponse() {
    *this = ::std::move(from);
  }

  inline DeleteFriendResponse& operator=(const DeleteFriendResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteFriendResponse& operator=(DeleteFriendResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteFriendResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteFriendResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteFriendResponse*>(
               &_DeleteFriendResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(DeleteFriendResponse& a, DeleteFriendResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteFriendResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteFriendResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteFriendResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteFriendResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteFriendResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteFriendResponse& from) {
    DeleteFriendResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteFriendResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.DeleteFriendResponse";
  }
  protected:
  explicit DeleteFriendResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kFrinedIdFieldNumber = 2,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // int32 frined_id = 2;
  void clear_frined_id();
  int32_t frined_id() const;
  void set_frined_id(int32_t value);
  private:
  int32_t _internal_frined_id() const;
  void _internal_set_frined_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.DeleteFriendResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    int32_t frined_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class FriendChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.FriendChatRequest) */ {
 public:
  inline FriendChatRequest() : FriendChatRequest(nullptr) {}
  ~FriendChatRequest() override;
  explicit PROTOBUF_CONSTEXPR FriendChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendChatRequest(const FriendChatRequest& from);
  FriendChatRequest(FriendChatRequest&& from) noexcept
    : FriendChatRequest() {
    *this = ::std::move(from);
  }

  inline FriendChatRequest& operator=(const FriendChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendChatRequest& operator=(FriendChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendChatRequest* internal_default_instance() {
    return reinterpret_cast<const FriendChatRequest*>(
               &_FriendChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(FriendChatRequest& a, FriendChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendChatRequest& from) {
    FriendChatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.FriendChatRequest";
  }
  protected:
  explicit FriendChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
    kTimeFieldNumber = 4,
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
  };
  // string content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string time = 4;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // .UserProto.Sender sender = 1;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::UserProto::Sender& sender() const;
  PROTOBUF_NODISCARD ::UserProto::Sender* release_sender();
  ::UserProto::Sender* mutable_sender();
  void set_allocated_sender(::UserProto::Sender* sender);
  private:
  const ::UserProto::Sender& _internal_sender() const;
  ::UserProto::Sender* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::UserProto::Sender* sender);
  ::UserProto::Sender* unsafe_arena_release_sender();

  // .UserProto.Receiver receiver = 2;
  bool has_receiver() const;
  private:
  bool _internal_has_receiver() const;
  public:
  void clear_receiver();
  const ::UserProto::Receiver& receiver() const;
  PROTOBUF_NODISCARD ::UserProto::Receiver* release_receiver();
  ::UserProto::Receiver* mutable_receiver();
  void set_allocated_receiver(::UserProto::Receiver* receiver);
  private:
  const ::UserProto::Receiver& _internal_receiver() const;
  ::UserProto::Receiver* _internal_mutable_receiver();
  public:
  void unsafe_arena_set_allocated_receiver(
      ::UserProto::Receiver* receiver);
  ::UserProto::Receiver* unsafe_arena_release_receiver();

  // @@protoc_insertion_point(class_scope:UserProto.FriendChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::UserProto::Sender* sender_;
    ::UserProto::Receiver* receiver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class FriendChatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.FriendChatResponse) */ {
 public:
  inline FriendChatResponse() : FriendChatResponse(nullptr) {}
  ~FriendChatResponse() override;
  explicit PROTOBUF_CONSTEXPR FriendChatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FriendChatResponse(const FriendChatResponse& from);
  FriendChatResponse(FriendChatResponse&& from) noexcept
    : FriendChatResponse() {
    *this = ::std::move(from);
  }

  inline FriendChatResponse& operator=(const FriendChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline FriendChatResponse& operator=(FriendChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FriendChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const FriendChatResponse* internal_default_instance() {
    return reinterpret_cast<const FriendChatResponse*>(
               &_FriendChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(FriendChatResponse& a, FriendChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(FriendChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FriendChatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  FriendChatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<FriendChatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FriendChatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const FriendChatResponse& from) {
    FriendChatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FriendChatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.FriendChatResponse";
  }
  protected:
  explicit FriendChatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.FriendChatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.CreateGroupRequest) */ {
 public:
  inline CreateGroupRequest() : CreateGroupRequest(nullptr) {}
  ~CreateGroupRequest() override;
  explicit PROTOBUF_CONSTEXPR CreateGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGroupRequest(const CreateGroupRequest& from);
  CreateGroupRequest(CreateGroupRequest&& from) noexcept
    : CreateGroupRequest() {
    *this = ::std::move(from);
  }

  inline CreateGroupRequest& operator=(const CreateGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGroupRequest& operator=(CreateGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGroupRequest* internal_default_instance() {
    return reinterpret_cast<const CreateGroupRequest*>(
               &_CreateGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(CreateGroupRequest& a, CreateGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGroupRequest& from) {
    CreateGroupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.CreateGroupRequest";
  }
  protected:
  explicit CreateGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupNameFieldNumber = 2,
    kGroupDescriptionFieldNumber = 3,
    kUserIdFieldNumber = 1,
  };
  // bytes group_name = 2;
  void clear_group_name();
  const std::string& group_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_name();
  PROTOBUF_NODISCARD std::string* release_group_name();
  void set_allocated_group_name(std::string* group_name);
  private:
  const std::string& _internal_group_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_name(const std::string& value);
  std::string* _internal_mutable_group_name();
  public:

  // bytes group_description = 3;
  void clear_group_description();
  const std::string& group_description() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_group_description(ArgT0&& arg0, ArgT... args);
  std::string* mutable_group_description();
  PROTOBUF_NODISCARD std::string* release_group_description();
  void set_allocated_group_description(std::string* group_description);
  private:
  const std::string& _internal_group_description() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_group_description(const std::string& value);
  std::string* _internal_mutable_group_description();
  public:

  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.CreateGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr group_description_;
    int32_t user_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class CreateGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.CreateGroupResponse) */ {
 public:
  inline CreateGroupResponse() : CreateGroupResponse(nullptr) {}
  ~CreateGroupResponse() override;
  explicit PROTOBUF_CONSTEXPR CreateGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CreateGroupResponse(const CreateGroupResponse& from);
  CreateGroupResponse(CreateGroupResponse&& from) noexcept
    : CreateGroupResponse() {
    *this = ::std::move(from);
  }

  inline CreateGroupResponse& operator=(const CreateGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CreateGroupResponse& operator=(CreateGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CreateGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CreateGroupResponse* internal_default_instance() {
    return reinterpret_cast<const CreateGroupResponse*>(
               &_CreateGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(CreateGroupResponse& a, CreateGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CreateGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CreateGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CreateGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CreateGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CreateGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const CreateGroupResponse& from) {
    CreateGroupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CreateGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.CreateGroupResponse";
  }
  protected:
  explicit CreateGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // .UserProto.Group group = 2;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::UserProto::Group& group() const;
  PROTOBUF_NODISCARD ::UserProto::Group* release_group();
  ::UserProto::Group* mutable_group();
  void set_allocated_group(::UserProto::Group* group);
  private:
  const ::UserProto::Group& _internal_group() const;
  ::UserProto::Group* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::UserProto::Group* group);
  ::UserProto::Group* unsafe_arena_release_group();

  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.CreateGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::UserProto::Group* group_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class AddGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.AddGroupRequest) */ {
 public:
  inline AddGroupRequest() : AddGroupRequest(nullptr) {}
  ~AddGroupRequest() override;
  explicit PROTOBUF_CONSTEXPR AddGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddGroupRequest(const AddGroupRequest& from);
  AddGroupRequest(AddGroupRequest&& from) noexcept
    : AddGroupRequest() {
    *this = ::std::move(from);
  }

  inline AddGroupRequest& operator=(const AddGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddGroupRequest& operator=(AddGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddGroupRequest* internal_default_instance() {
    return reinterpret_cast<const AddGroupRequest*>(
               &_AddGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(AddGroupRequest& a, AddGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(AddGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddGroupRequest& from) {
    AddGroupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.AddGroupRequest";
  }
  protected:
  explicit AddGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kGroupIdFieldNumber = 2,
  };
  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // int32 group_id = 2;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.AddGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t user_id_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class AddGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.AddGroupResponse) */ {
 public:
  inline AddGroupResponse() : AddGroupResponse(nullptr) {}
  ~AddGroupResponse() override;
  explicit PROTOBUF_CONSTEXPR AddGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AddGroupResponse(const AddGroupResponse& from);
  AddGroupResponse(AddGroupResponse&& from) noexcept
    : AddGroupResponse() {
    *this = ::std::move(from);
  }

  inline AddGroupResponse& operator=(const AddGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AddGroupResponse& operator=(AddGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AddGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AddGroupResponse* internal_default_instance() {
    return reinterpret_cast<const AddGroupResponse*>(
               &_AddGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(AddGroupResponse& a, AddGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AddGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AddGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  AddGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<AddGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AddGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const AddGroupResponse& from) {
    AddGroupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.AddGroupResponse";
  }
  protected:
  explicit AddGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGroupFieldNumber = 2,
    kErrorCodeFieldNumber = 1,
  };
  // .UserProto.Group group = 2;
  bool has_group() const;
  private:
  bool _internal_has_group() const;
  public:
  void clear_group();
  const ::UserProto::Group& group() const;
  PROTOBUF_NODISCARD ::UserProto::Group* release_group();
  ::UserProto::Group* mutable_group();
  void set_allocated_group(::UserProto::Group* group);
  private:
  const ::UserProto::Group& _internal_group() const;
  ::UserProto::Group* _internal_mutable_group();
  public:
  void unsafe_arena_set_allocated_group(
      ::UserProto::Group* group);
  ::UserProto::Group* unsafe_arena_release_group();

  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.AddGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::UserProto::Group* group_;
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class DeleteGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.DeleteGroupRequest) */ {
 public:
  inline DeleteGroupRequest() : DeleteGroupRequest(nullptr) {}
  ~DeleteGroupRequest() override;
  explicit PROTOBUF_CONSTEXPR DeleteGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteGroupRequest(const DeleteGroupRequest& from);
  DeleteGroupRequest(DeleteGroupRequest&& from) noexcept
    : DeleteGroupRequest() {
    *this = ::std::move(from);
  }

  inline DeleteGroupRequest& operator=(const DeleteGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteGroupRequest& operator=(DeleteGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteGroupRequest* internal_default_instance() {
    return reinterpret_cast<const DeleteGroupRequest*>(
               &_DeleteGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(DeleteGroupRequest& a, DeleteGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteGroupRequest& from) {
    DeleteGroupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.DeleteGroupRequest";
  }
  protected:
  explicit DeleteGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kGroupIdFieldNumber = 2,
  };
  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // int32 group_id = 2;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.DeleteGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t user_id_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class DeleteGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.DeleteGroupResponse) */ {
 public:
  inline DeleteGroupResponse() : DeleteGroupResponse(nullptr) {}
  ~DeleteGroupResponse() override;
  explicit PROTOBUF_CONSTEXPR DeleteGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DeleteGroupResponse(const DeleteGroupResponse& from);
  DeleteGroupResponse(DeleteGroupResponse&& from) noexcept
    : DeleteGroupResponse() {
    *this = ::std::move(from);
  }

  inline DeleteGroupResponse& operator=(const DeleteGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline DeleteGroupResponse& operator=(DeleteGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const DeleteGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const DeleteGroupResponse* internal_default_instance() {
    return reinterpret_cast<const DeleteGroupResponse*>(
               &_DeleteGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(DeleteGroupResponse& a, DeleteGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(DeleteGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DeleteGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DeleteGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DeleteGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const DeleteGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const DeleteGroupResponse& from) {
    DeleteGroupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.DeleteGroupResponse";
  }
  protected:
  explicit DeleteGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kGroupIdFieldNumber = 2,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // int32 group_id = 2;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.DeleteGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class QuitGroupRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.QuitGroupRequest) */ {
 public:
  inline QuitGroupRequest() : QuitGroupRequest(nullptr) {}
  ~QuitGroupRequest() override;
  explicit PROTOBUF_CONSTEXPR QuitGroupRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuitGroupRequest(const QuitGroupRequest& from);
  QuitGroupRequest(QuitGroupRequest&& from) noexcept
    : QuitGroupRequest() {
    *this = ::std::move(from);
  }

  inline QuitGroupRequest& operator=(const QuitGroupRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuitGroupRequest& operator=(QuitGroupRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuitGroupRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuitGroupRequest* internal_default_instance() {
    return reinterpret_cast<const QuitGroupRequest*>(
               &_QuitGroupRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(QuitGroupRequest& a, QuitGroupRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(QuitGroupRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuitGroupRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuitGroupRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuitGroupRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuitGroupRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuitGroupRequest& from) {
    QuitGroupRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuitGroupRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.QuitGroupRequest";
  }
  protected:
  explicit QuitGroupRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUserIdFieldNumber = 1,
    kGroupIdFieldNumber = 2,
  };
  // int32 user_id = 1;
  void clear_user_id();
  int32_t user_id() const;
  void set_user_id(int32_t value);
  private:
  int32_t _internal_user_id() const;
  void _internal_set_user_id(int32_t value);
  public:

  // int32 group_id = 2;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.QuitGroupRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t user_id_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class QuitGroupResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.QuitGroupResponse) */ {
 public:
  inline QuitGroupResponse() : QuitGroupResponse(nullptr) {}
  ~QuitGroupResponse() override;
  explicit PROTOBUF_CONSTEXPR QuitGroupResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  QuitGroupResponse(const QuitGroupResponse& from);
  QuitGroupResponse(QuitGroupResponse&& from) noexcept
    : QuitGroupResponse() {
    *this = ::std::move(from);
  }

  inline QuitGroupResponse& operator=(const QuitGroupResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline QuitGroupResponse& operator=(QuitGroupResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const QuitGroupResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const QuitGroupResponse* internal_default_instance() {
    return reinterpret_cast<const QuitGroupResponse*>(
               &_QuitGroupResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(QuitGroupResponse& a, QuitGroupResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(QuitGroupResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(QuitGroupResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  QuitGroupResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<QuitGroupResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const QuitGroupResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const QuitGroupResponse& from) {
    QuitGroupResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(QuitGroupResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.QuitGroupResponse";
  }
  protected:
  explicit QuitGroupResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
    kGroupIdFieldNumber = 2,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // int32 group_id = 2;
  void clear_group_id();
  int32_t group_id() const;
  void set_group_id(int32_t value);
  private:
  int32_t _internal_group_id() const;
  void _internal_set_group_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.QuitGroupResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    int32_t group_id_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GroupChatRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.GroupChatRequest) */ {
 public:
  inline GroupChatRequest() : GroupChatRequest(nullptr) {}
  ~GroupChatRequest() override;
  explicit PROTOBUF_CONSTEXPR GroupChatRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupChatRequest(const GroupChatRequest& from);
  GroupChatRequest(GroupChatRequest&& from) noexcept
    : GroupChatRequest() {
    *this = ::std::move(from);
  }

  inline GroupChatRequest& operator=(const GroupChatRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupChatRequest& operator=(GroupChatRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupChatRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupChatRequest* internal_default_instance() {
    return reinterpret_cast<const GroupChatRequest*>(
               &_GroupChatRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GroupChatRequest& a, GroupChatRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupChatRequest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupChatRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupChatRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupChatRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupChatRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupChatRequest& from) {
    GroupChatRequest::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupChatRequest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.GroupChatRequest";
  }
  protected:
  explicit GroupChatRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kContentFieldNumber = 3,
    kTimeFieldNumber = 4,
    kSenderFieldNumber = 1,
    kReceiverFieldNumber = 2,
  };
  // string content = 3;
  void clear_content();
  const std::string& content() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_content(ArgT0&& arg0, ArgT... args);
  std::string* mutable_content();
  PROTOBUF_NODISCARD std::string* release_content();
  void set_allocated_content(std::string* content);
  private:
  const std::string& _internal_content() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_content(const std::string& value);
  std::string* _internal_mutable_content();
  public:

  // string time = 4;
  void clear_time();
  const std::string& time() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_time(ArgT0&& arg0, ArgT... args);
  std::string* mutable_time();
  PROTOBUF_NODISCARD std::string* release_time();
  void set_allocated_time(std::string* time);
  private:
  const std::string& _internal_time() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_time(const std::string& value);
  std::string* _internal_mutable_time();
  public:

  // .UserProto.Sender sender = 1;
  bool has_sender() const;
  private:
  bool _internal_has_sender() const;
  public:
  void clear_sender();
  const ::UserProto::Sender& sender() const;
  PROTOBUF_NODISCARD ::UserProto::Sender* release_sender();
  ::UserProto::Sender* mutable_sender();
  void set_allocated_sender(::UserProto::Sender* sender);
  private:
  const ::UserProto::Sender& _internal_sender() const;
  ::UserProto::Sender* _internal_mutable_sender();
  public:
  void unsafe_arena_set_allocated_sender(
      ::UserProto::Sender* sender);
  ::UserProto::Sender* unsafe_arena_release_sender();

  // .UserProto.Receiver receiver = 2;
  bool has_receiver() const;
  private:
  bool _internal_has_receiver() const;
  public:
  void clear_receiver();
  const ::UserProto::Receiver& receiver() const;
  PROTOBUF_NODISCARD ::UserProto::Receiver* release_receiver();
  ::UserProto::Receiver* mutable_receiver();
  void set_allocated_receiver(::UserProto::Receiver* receiver);
  private:
  const ::UserProto::Receiver& _internal_receiver() const;
  ::UserProto::Receiver* _internal_mutable_receiver();
  public:
  void unsafe_arena_set_allocated_receiver(
      ::UserProto::Receiver* receiver);
  ::UserProto::Receiver* unsafe_arena_release_receiver();

  // @@protoc_insertion_point(class_scope:UserProto.GroupChatRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr content_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr time_;
    ::UserProto::Sender* sender_;
    ::UserProto::Receiver* receiver_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class GroupChatResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:UserProto.GroupChatResponse) */ {
 public:
  inline GroupChatResponse() : GroupChatResponse(nullptr) {}
  ~GroupChatResponse() override;
  explicit PROTOBUF_CONSTEXPR GroupChatResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GroupChatResponse(const GroupChatResponse& from);
  GroupChatResponse(GroupChatResponse&& from) noexcept
    : GroupChatResponse() {
    *this = ::std::move(from);
  }

  inline GroupChatResponse& operator=(const GroupChatResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GroupChatResponse& operator=(GroupChatResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GroupChatResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GroupChatResponse* internal_default_instance() {
    return reinterpret_cast<const GroupChatResponse*>(
               &_GroupChatResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(GroupChatResponse& a, GroupChatResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GroupChatResponse* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GroupChatResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  GroupChatResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<GroupChatResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GroupChatResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const GroupChatResponse& from) {
    GroupChatResponse::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GroupChatResponse* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "UserProto.GroupChatResponse";
  }
  protected:
  explicit GroupChatResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kErrorCodeFieldNumber = 1,
  };
  // int32 error_code = 1;
  void clear_error_code();
  int32_t error_code() const;
  void set_error_code(int32_t value);
  private:
  int32_t _internal_error_code() const;
  void _internal_set_error_code(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:UserProto.GroupChatResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t error_code_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_user_2eproto;
};
// ===================================================================

class UserServiceRpc_Stub;

class UserServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline UserServiceRpc() {};
 public:
  virtual ~UserServiceRpc();

  typedef UserServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void Login(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::LoginRequest* request,
                       ::UserProto::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void Register(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::RegisterRequest* request,
                       ::UserProto::RegisterResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void Logout(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::LogoutRequest* request,
                       ::UserProto::LogoutResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(UserServiceRpc);
};

class UserServiceRpc_Stub : public UserServiceRpc {
 public:
  UserServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  UserServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~UserServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements UserServiceRpc ------------------------------------------

  void Login(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::LoginRequest* request,
                       ::UserProto::LoginResponse* response,
                       ::google::protobuf::Closure* done);
  void Register(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::RegisterRequest* request,
                       ::UserProto::RegisterResponse* response,
                       ::google::protobuf::Closure* done);
  void Logout(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::LogoutRequest* request,
                       ::UserProto::LogoutResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(UserServiceRpc_Stub);
};


// -------------------------------------------------------------------

class FriendServiceRpc_Stub;

class FriendServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline FriendServiceRpc() {};
 public:
  virtual ~FriendServiceRpc();

  typedef FriendServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void AddFriend(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::AddFriendRequest* request,
                       ::UserProto::AddFriendResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void DeleteFriend(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::DeleteFriendRequest* request,
                       ::UserProto::DeleteFriendResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(FriendServiceRpc);
};

class FriendServiceRpc_Stub : public FriendServiceRpc {
 public:
  FriendServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  FriendServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~FriendServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements FriendServiceRpc ------------------------------------------

  void AddFriend(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::AddFriendRequest* request,
                       ::UserProto::AddFriendResponse* response,
                       ::google::protobuf::Closure* done);
  void DeleteFriend(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::DeleteFriendRequest* request,
                       ::UserProto::DeleteFriendResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(FriendServiceRpc_Stub);
};


// -------------------------------------------------------------------

class OneChatServiceRpc_Stub;

class OneChatServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline OneChatServiceRpc() {};
 public:
  virtual ~OneChatServiceRpc();

  typedef OneChatServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void FriendChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::FriendChatRequest* request,
                       ::UserProto::FriendChatResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(OneChatServiceRpc);
};

class OneChatServiceRpc_Stub : public OneChatServiceRpc {
 public:
  OneChatServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  OneChatServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~OneChatServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements OneChatServiceRpc ------------------------------------------

  void FriendChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::FriendChatRequest* request,
                       ::UserProto::FriendChatResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(OneChatServiceRpc_Stub);
};


// -------------------------------------------------------------------

class GroupServiceRpc_Stub;

class GroupServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline GroupServiceRpc() {};
 public:
  virtual ~GroupServiceRpc();

  typedef GroupServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void CreateGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::CreateGroupRequest* request,
                       ::UserProto::CreateGroupResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void AddGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::AddGroupRequest* request,
                       ::UserProto::AddGroupResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void DeleteGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::DeleteGroupRequest* request,
                       ::UserProto::DeleteGroupResponse* response,
                       ::google::protobuf::Closure* done);
  virtual void QuitGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::QuitGroupRequest* request,
                       ::UserProto::QuitGroupResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GroupServiceRpc);
};

class GroupServiceRpc_Stub : public GroupServiceRpc {
 public:
  GroupServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  GroupServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~GroupServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements GroupServiceRpc ------------------------------------------

  void CreateGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::CreateGroupRequest* request,
                       ::UserProto::CreateGroupResponse* response,
                       ::google::protobuf::Closure* done);
  void AddGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::AddGroupRequest* request,
                       ::UserProto::AddGroupResponse* response,
                       ::google::protobuf::Closure* done);
  void DeleteGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::DeleteGroupRequest* request,
                       ::UserProto::DeleteGroupResponse* response,
                       ::google::protobuf::Closure* done);
  void QuitGroup(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::QuitGroupRequest* request,
                       ::UserProto::QuitGroupResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GroupServiceRpc_Stub);
};


// -------------------------------------------------------------------

class GroupChatServiceRpc_Stub;

class GroupChatServiceRpc : public ::PROTOBUF_NAMESPACE_ID::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline GroupChatServiceRpc() {};
 public:
  virtual ~GroupChatServiceRpc();

  typedef GroupChatServiceRpc_Stub Stub;

  static const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* descriptor();

  virtual void GroupChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::GroupChatRequest* request,
                       ::UserProto::GroupChatResponse* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method,
                  ::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                  const ::PROTOBUF_NAMESPACE_ID::Message* request,
                  ::PROTOBUF_NAMESPACE_ID::Message* response,
                  ::google::protobuf::Closure* done);
  const ::PROTOBUF_NAMESPACE_ID::Message& GetRequestPrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;
  const ::PROTOBUF_NAMESPACE_ID::Message& GetResponsePrototype(
    const ::PROTOBUF_NAMESPACE_ID::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GroupChatServiceRpc);
};

class GroupChatServiceRpc_Stub : public GroupChatServiceRpc {
 public:
  GroupChatServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel);
  GroupChatServiceRpc_Stub(::PROTOBUF_NAMESPACE_ID::RpcChannel* channel,
                   ::PROTOBUF_NAMESPACE_ID::Service::ChannelOwnership ownership);
  ~GroupChatServiceRpc_Stub();

  inline ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel() { return channel_; }

  // implements GroupChatServiceRpc ------------------------------------------

  void GroupChat(::PROTOBUF_NAMESPACE_ID::RpcController* controller,
                       const ::UserProto::GroupChatRequest* request,
                       ::UserProto::GroupChatResponse* response,
                       ::google::protobuf::Closure* done);
 private:
  ::PROTOBUF_NAMESPACE_ID::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(GroupChatServiceRpc_Stub);
};


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// int32 user_id = 1;
inline void User::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t User::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t User::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.User.user_id)
  return _internal_user_id();
}
inline void User::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void User::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.User.user_id)
}

// bytes user_name = 2;
inline void User::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& User::user_name() const {
  // @@protoc_insertion_point(field_get:UserProto.User.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.User.user_name)
}
inline std::string* User::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:UserProto.User.user_name)
  return _s;
}
inline const std::string& User::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void User::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_user_name() {
  // @@protoc_insertion_point(field_release:UserProto.User.user_name)
  return _impl_.user_name_.Release();
}
inline void User::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.User.user_name)
}

// bytes user_state = 3;
inline void User::clear_user_state() {
  _impl_.user_state_.ClearToEmpty();
}
inline const std::string& User::user_state() const {
  // @@protoc_insertion_point(field_get:UserProto.User.user_state)
  return _internal_user_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_state_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.User.user_state)
}
inline std::string* User::mutable_user_state() {
  std::string* _s = _internal_mutable_user_state();
  // @@protoc_insertion_point(field_mutable:UserProto.User.user_state)
  return _s;
}
inline const std::string& User::_internal_user_state() const {
  return _impl_.user_state_.Get();
}
inline void User::_internal_set_user_state(const std::string& value) {
  
  _impl_.user_state_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_state() {
  
  return _impl_.user_state_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_user_state() {
  // @@protoc_insertion_point(field_release:UserProto.User.user_state)
  return _impl_.user_state_.Release();
}
inline void User::set_allocated_user_state(std::string* user_state) {
  if (user_state != nullptr) {
    
  } else {
    
  }
  _impl_.user_state_.SetAllocated(user_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_state_.IsDefault()) {
    _impl_.user_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.User.user_state)
}

// bytes user_password = 4;
inline void User::clear_user_password() {
  _impl_.user_password_.ClearToEmpty();
}
inline const std::string& User::user_password() const {
  // @@protoc_insertion_point(field_get:UserProto.User.user_password)
  return _internal_user_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_user_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.User.user_password)
}
inline std::string* User::mutable_user_password() {
  std::string* _s = _internal_mutable_user_password();
  // @@protoc_insertion_point(field_mutable:UserProto.User.user_password)
  return _s;
}
inline const std::string& User::_internal_user_password() const {
  return _impl_.user_password_.Get();
}
inline void User::_internal_set_user_password(const std::string& value) {
  
  _impl_.user_password_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_user_password() {
  
  return _impl_.user_password_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_user_password() {
  // @@protoc_insertion_point(field_release:UserProto.User.user_password)
  return _impl_.user_password_.Release();
}
inline void User::set_allocated_user_password(std::string* user_password) {
  if (user_password != nullptr) {
    
  } else {
    
  }
  _impl_.user_password_.SetAllocated(user_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_password_.IsDefault()) {
    _impl_.user_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.User.user_password)
}

// string last_offline_time = 5;
inline void User::clear_last_offline_time() {
  _impl_.last_offline_time_.ClearToEmpty();
}
inline const std::string& User::last_offline_time() const {
  // @@protoc_insertion_point(field_get:UserProto.User.last_offline_time)
  return _internal_last_offline_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_last_offline_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.last_offline_time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.User.last_offline_time)
}
inline std::string* User::mutable_last_offline_time() {
  std::string* _s = _internal_mutable_last_offline_time();
  // @@protoc_insertion_point(field_mutable:UserProto.User.last_offline_time)
  return _s;
}
inline const std::string& User::_internal_last_offline_time() const {
  return _impl_.last_offline_time_.Get();
}
inline void User::_internal_set_last_offline_time(const std::string& value) {
  
  _impl_.last_offline_time_.Set(value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_last_offline_time() {
  
  return _impl_.last_offline_time_.Mutable(GetArenaForAllocation());
}
inline std::string* User::release_last_offline_time() {
  // @@protoc_insertion_point(field_release:UserProto.User.last_offline_time)
  return _impl_.last_offline_time_.Release();
}
inline void User::set_allocated_last_offline_time(std::string* last_offline_time) {
  if (last_offline_time != nullptr) {
    
  } else {
    
  }
  _impl_.last_offline_time_.SetAllocated(last_offline_time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.last_offline_time_.IsDefault()) {
    _impl_.last_offline_time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.User.last_offline_time)
}

// -------------------------------------------------------------------

// FriendUser

// int32 friend_id = 1;
inline void FriendUser::clear_friend_id() {
  _impl_.friend_id_ = 0;
}
inline int32_t FriendUser::_internal_friend_id() const {
  return _impl_.friend_id_;
}
inline int32_t FriendUser::friend_id() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendUser.friend_id)
  return _internal_friend_id();
}
inline void FriendUser::_internal_set_friend_id(int32_t value) {
  
  _impl_.friend_id_ = value;
}
inline void FriendUser::set_friend_id(int32_t value) {
  _internal_set_friend_id(value);
  // @@protoc_insertion_point(field_set:UserProto.FriendUser.friend_id)
}

// bytes friend_name = 2;
inline void FriendUser::clear_friend_name() {
  _impl_.friend_name_.ClearToEmpty();
}
inline const std::string& FriendUser::friend_name() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendUser.friend_name)
  return _internal_friend_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendUser::set_friend_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.friend_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.FriendUser.friend_name)
}
inline std::string* FriendUser::mutable_friend_name() {
  std::string* _s = _internal_mutable_friend_name();
  // @@protoc_insertion_point(field_mutable:UserProto.FriendUser.friend_name)
  return _s;
}
inline const std::string& FriendUser::_internal_friend_name() const {
  return _impl_.friend_name_.Get();
}
inline void FriendUser::_internal_set_friend_name(const std::string& value) {
  
  _impl_.friend_name_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendUser::_internal_mutable_friend_name() {
  
  return _impl_.friend_name_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendUser::release_friend_name() {
  // @@protoc_insertion_point(field_release:UserProto.FriendUser.friend_name)
  return _impl_.friend_name_.Release();
}
inline void FriendUser::set_allocated_friend_name(std::string* friend_name) {
  if (friend_name != nullptr) {
    
  } else {
    
  }
  _impl_.friend_name_.SetAllocated(friend_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.friend_name_.IsDefault()) {
    _impl_.friend_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.FriendUser.friend_name)
}

// bytes friend_state = 3;
inline void FriendUser::clear_friend_state() {
  _impl_.friend_state_.ClearToEmpty();
}
inline const std::string& FriendUser::friend_state() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendUser.friend_state)
  return _internal_friend_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendUser::set_friend_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.friend_state_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.FriendUser.friend_state)
}
inline std::string* FriendUser::mutable_friend_state() {
  std::string* _s = _internal_mutable_friend_state();
  // @@protoc_insertion_point(field_mutable:UserProto.FriendUser.friend_state)
  return _s;
}
inline const std::string& FriendUser::_internal_friend_state() const {
  return _impl_.friend_state_.Get();
}
inline void FriendUser::_internal_set_friend_state(const std::string& value) {
  
  _impl_.friend_state_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendUser::_internal_mutable_friend_state() {
  
  return _impl_.friend_state_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendUser::release_friend_state() {
  // @@protoc_insertion_point(field_release:UserProto.FriendUser.friend_state)
  return _impl_.friend_state_.Release();
}
inline void FriendUser::set_allocated_friend_state(std::string* friend_state) {
  if (friend_state != nullptr) {
    
  } else {
    
  }
  _impl_.friend_state_.SetAllocated(friend_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.friend_state_.IsDefault()) {
    _impl_.friend_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.FriendUser.friend_state)
}

// -------------------------------------------------------------------

// FriendList

// repeated .UserProto.FriendUser friend_users = 1;
inline int FriendList::_internal_friend_users_size() const {
  return _impl_.friend_users_.size();
}
inline int FriendList::friend_users_size() const {
  return _internal_friend_users_size();
}
inline void FriendList::clear_friend_users() {
  _impl_.friend_users_.Clear();
}
inline ::UserProto::FriendUser* FriendList::mutable_friend_users(int index) {
  // @@protoc_insertion_point(field_mutable:UserProto.FriendList.friend_users)
  return _impl_.friend_users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::FriendUser >*
FriendList::mutable_friend_users() {
  // @@protoc_insertion_point(field_mutable_list:UserProto.FriendList.friend_users)
  return &_impl_.friend_users_;
}
inline const ::UserProto::FriendUser& FriendList::_internal_friend_users(int index) const {
  return _impl_.friend_users_.Get(index);
}
inline const ::UserProto::FriendUser& FriendList::friend_users(int index) const {
  // @@protoc_insertion_point(field_get:UserProto.FriendList.friend_users)
  return _internal_friend_users(index);
}
inline ::UserProto::FriendUser* FriendList::_internal_add_friend_users() {
  return _impl_.friend_users_.Add();
}
inline ::UserProto::FriendUser* FriendList::add_friend_users() {
  ::UserProto::FriendUser* _add = _internal_add_friend_users();
  // @@protoc_insertion_point(field_add:UserProto.FriendList.friend_users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::FriendUser >&
FriendList::friend_users() const {
  // @@protoc_insertion_point(field_list:UserProto.FriendList.friend_users)
  return _impl_.friend_users_;
}

// -------------------------------------------------------------------

// GroupUser

// int32 user_id = 1;
inline void GroupUser::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t GroupUser::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t GroupUser::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupUser.user_id)
  return _internal_user_id();
}
inline void GroupUser::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void GroupUser::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.GroupUser.user_id)
}

// bytes user_name = 2;
inline void GroupUser::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& GroupUser::user_name() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupUser.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupUser::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.GroupUser.user_name)
}
inline std::string* GroupUser::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupUser.user_name)
  return _s;
}
inline const std::string& GroupUser::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void GroupUser::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupUser::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupUser::release_user_name() {
  // @@protoc_insertion_point(field_release:UserProto.GroupUser.user_name)
  return _impl_.user_name_.Release();
}
inline void GroupUser::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupUser.user_name)
}

// bytes user_state = 3;
inline void GroupUser::clear_user_state() {
  _impl_.user_state_.ClearToEmpty();
}
inline const std::string& GroupUser::user_state() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupUser.user_state)
  return _internal_user_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupUser::set_user_state(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_state_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.GroupUser.user_state)
}
inline std::string* GroupUser::mutable_user_state() {
  std::string* _s = _internal_mutable_user_state();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupUser.user_state)
  return _s;
}
inline const std::string& GroupUser::_internal_user_state() const {
  return _impl_.user_state_.Get();
}
inline void GroupUser::_internal_set_user_state(const std::string& value) {
  
  _impl_.user_state_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupUser::_internal_mutable_user_state() {
  
  return _impl_.user_state_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupUser::release_user_state() {
  // @@protoc_insertion_point(field_release:UserProto.GroupUser.user_state)
  return _impl_.user_state_.Release();
}
inline void GroupUser::set_allocated_user_state(std::string* user_state) {
  if (user_state != nullptr) {
    
  } else {
    
  }
  _impl_.user_state_.SetAllocated(user_state, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_state_.IsDefault()) {
    _impl_.user_state_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupUser.user_state)
}

// bytes user_role = 4;
inline void GroupUser::clear_user_role() {
  _impl_.user_role_.ClearToEmpty();
}
inline const std::string& GroupUser::user_role() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupUser.user_role)
  return _internal_user_role();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupUser::set_user_role(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_role_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.GroupUser.user_role)
}
inline std::string* GroupUser::mutable_user_role() {
  std::string* _s = _internal_mutable_user_role();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupUser.user_role)
  return _s;
}
inline const std::string& GroupUser::_internal_user_role() const {
  return _impl_.user_role_.Get();
}
inline void GroupUser::_internal_set_user_role(const std::string& value) {
  
  _impl_.user_role_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupUser::_internal_mutable_user_role() {
  
  return _impl_.user_role_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupUser::release_user_role() {
  // @@protoc_insertion_point(field_release:UserProto.GroupUser.user_role)
  return _impl_.user_role_.Release();
}
inline void GroupUser::set_allocated_user_role(std::string* user_role) {
  if (user_role != nullptr) {
    
  } else {
    
  }
  _impl_.user_role_.SetAllocated(user_role, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_role_.IsDefault()) {
    _impl_.user_role_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupUser.user_role)
}

// -------------------------------------------------------------------

// Group

// int32 group_id = 1;
inline void Group::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t Group::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t Group::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.Group.group_id)
  return _internal_group_id();
}
inline void Group::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void Group::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.Group.group_id)
}

// bytes group_name = 2;
inline void Group::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
}
inline const std::string& Group::group_name() const {
  // @@protoc_insertion_point(field_get:UserProto.Group.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Group::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Group.group_name)
}
inline std::string* Group::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:UserProto.Group.group_name)
  return _s;
}
inline const std::string& Group::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void Group::_internal_set_group_name(const std::string& value) {
  
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Group::_internal_mutable_group_name() {
  
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Group::release_group_name() {
  // @@protoc_insertion_point(field_release:UserProto.Group.group_name)
  return _impl_.group_name_.Release();
}
inline void Group::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Group.group_name)
}

// bytes group_description = 3;
inline void Group::clear_group_description() {
  _impl_.group_description_.ClearToEmpty();
}
inline const std::string& Group::group_description() const {
  // @@protoc_insertion_point(field_get:UserProto.Group.group_description)
  return _internal_group_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Group::set_group_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_description_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Group.group_description)
}
inline std::string* Group::mutable_group_description() {
  std::string* _s = _internal_mutable_group_description();
  // @@protoc_insertion_point(field_mutable:UserProto.Group.group_description)
  return _s;
}
inline const std::string& Group::_internal_group_description() const {
  return _impl_.group_description_.Get();
}
inline void Group::_internal_set_group_description(const std::string& value) {
  
  _impl_.group_description_.Set(value, GetArenaForAllocation());
}
inline std::string* Group::_internal_mutable_group_description() {
  
  return _impl_.group_description_.Mutable(GetArenaForAllocation());
}
inline std::string* Group::release_group_description() {
  // @@protoc_insertion_point(field_release:UserProto.Group.group_description)
  return _impl_.group_description_.Release();
}
inline void Group::set_allocated_group_description(std::string* group_description) {
  if (group_description != nullptr) {
    
  } else {
    
  }
  _impl_.group_description_.SetAllocated(group_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_description_.IsDefault()) {
    _impl_.group_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Group.group_description)
}

// .UserProto.GroupUserList group_user_list = 4;
inline bool Group::_internal_has_group_user_list() const {
  return this != internal_default_instance() && _impl_.group_user_list_ != nullptr;
}
inline bool Group::has_group_user_list() const {
  return _internal_has_group_user_list();
}
inline void Group::clear_group_user_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_user_list_ != nullptr) {
    delete _impl_.group_user_list_;
  }
  _impl_.group_user_list_ = nullptr;
}
inline const ::UserProto::GroupUserList& Group::_internal_group_user_list() const {
  const ::UserProto::GroupUserList* p = _impl_.group_user_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::GroupUserList&>(
      ::UserProto::_GroupUserList_default_instance_);
}
inline const ::UserProto::GroupUserList& Group::group_user_list() const {
  // @@protoc_insertion_point(field_get:UserProto.Group.group_user_list)
  return _internal_group_user_list();
}
inline void Group::unsafe_arena_set_allocated_group_user_list(
    ::UserProto::GroupUserList* group_user_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_user_list_);
  }
  _impl_.group_user_list_ = group_user_list;
  if (group_user_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.Group.group_user_list)
}
inline ::UserProto::GroupUserList* Group::release_group_user_list() {
  
  ::UserProto::GroupUserList* temp = _impl_.group_user_list_;
  _impl_.group_user_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::GroupUserList* Group::unsafe_arena_release_group_user_list() {
  // @@protoc_insertion_point(field_release:UserProto.Group.group_user_list)
  
  ::UserProto::GroupUserList* temp = _impl_.group_user_list_;
  _impl_.group_user_list_ = nullptr;
  return temp;
}
inline ::UserProto::GroupUserList* Group::_internal_mutable_group_user_list() {
  
  if (_impl_.group_user_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::GroupUserList>(GetArenaForAllocation());
    _impl_.group_user_list_ = p;
  }
  return _impl_.group_user_list_;
}
inline ::UserProto::GroupUserList* Group::mutable_group_user_list() {
  ::UserProto::GroupUserList* _msg = _internal_mutable_group_user_list();
  // @@protoc_insertion_point(field_mutable:UserProto.Group.group_user_list)
  return _msg;
}
inline void Group::set_allocated_group_user_list(::UserProto::GroupUserList* group_user_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_user_list_;
  }
  if (group_user_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_user_list);
    if (message_arena != submessage_arena) {
      group_user_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_user_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_user_list_ = group_user_list;
  // @@protoc_insertion_point(field_set_allocated:UserProto.Group.group_user_list)
}

// -------------------------------------------------------------------

// GroupList

// repeated .UserProto.Group groups = 1;
inline int GroupList::_internal_groups_size() const {
  return _impl_.groups_.size();
}
inline int GroupList::groups_size() const {
  return _internal_groups_size();
}
inline void GroupList::clear_groups() {
  _impl_.groups_.Clear();
}
inline ::UserProto::Group* GroupList::mutable_groups(int index) {
  // @@protoc_insertion_point(field_mutable:UserProto.GroupList.groups)
  return _impl_.groups_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Group >*
GroupList::mutable_groups() {
  // @@protoc_insertion_point(field_mutable_list:UserProto.GroupList.groups)
  return &_impl_.groups_;
}
inline const ::UserProto::Group& GroupList::_internal_groups(int index) const {
  return _impl_.groups_.Get(index);
}
inline const ::UserProto::Group& GroupList::groups(int index) const {
  // @@protoc_insertion_point(field_get:UserProto.GroupList.groups)
  return _internal_groups(index);
}
inline ::UserProto::Group* GroupList::_internal_add_groups() {
  return _impl_.groups_.Add();
}
inline ::UserProto::Group* GroupList::add_groups() {
  ::UserProto::Group* _add = _internal_add_groups();
  // @@protoc_insertion_point(field_add:UserProto.GroupList.groups)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Group >&
GroupList::groups() const {
  // @@protoc_insertion_point(field_list:UserProto.GroupList.groups)
  return _impl_.groups_;
}

// -------------------------------------------------------------------

// GroupUserList

// repeated .UserProto.GroupUser group_users = 1;
inline int GroupUserList::_internal_group_users_size() const {
  return _impl_.group_users_.size();
}
inline int GroupUserList::group_users_size() const {
  return _internal_group_users_size();
}
inline void GroupUserList::clear_group_users() {
  _impl_.group_users_.Clear();
}
inline ::UserProto::GroupUser* GroupUserList::mutable_group_users(int index) {
  // @@protoc_insertion_point(field_mutable:UserProto.GroupUserList.group_users)
  return _impl_.group_users_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::GroupUser >*
GroupUserList::mutable_group_users() {
  // @@protoc_insertion_point(field_mutable_list:UserProto.GroupUserList.group_users)
  return &_impl_.group_users_;
}
inline const ::UserProto::GroupUser& GroupUserList::_internal_group_users(int index) const {
  return _impl_.group_users_.Get(index);
}
inline const ::UserProto::GroupUser& GroupUserList::group_users(int index) const {
  // @@protoc_insertion_point(field_get:UserProto.GroupUserList.group_users)
  return _internal_group_users(index);
}
inline ::UserProto::GroupUser* GroupUserList::_internal_add_group_users() {
  return _impl_.group_users_.Add();
}
inline ::UserProto::GroupUser* GroupUserList::add_group_users() {
  ::UserProto::GroupUser* _add = _internal_add_group_users();
  // @@protoc_insertion_point(field_add:UserProto.GroupUserList.group_users)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::GroupUser >&
GroupUserList::group_users() const {
  // @@protoc_insertion_point(field_list:UserProto.GroupUserList.group_users)
  return _impl_.group_users_;
}

// -------------------------------------------------------------------

// BroadcastMessage

// .UserProto.MessageType message_type = 1;
inline void BroadcastMessage::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::UserProto::MessageType BroadcastMessage::_internal_message_type() const {
  return static_cast< ::UserProto::MessageType >(_impl_.message_type_);
}
inline ::UserProto::MessageType BroadcastMessage::message_type() const {
  // @@protoc_insertion_point(field_get:UserProto.BroadcastMessage.message_type)
  return _internal_message_type();
}
inline void BroadcastMessage::_internal_set_message_type(::UserProto::MessageType value) {
  
  _impl_.message_type_ = value;
}
inline void BroadcastMessage::set_message_type(::UserProto::MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:UserProto.BroadcastMessage.message_type)
}

// bytes content = 2;
inline void BroadcastMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& BroadcastMessage::content() const {
  // @@protoc_insertion_point(field_get:UserProto.BroadcastMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BroadcastMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.BroadcastMessage.content)
}
inline std::string* BroadcastMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:UserProto.BroadcastMessage.content)
  return _s;
}
inline const std::string& BroadcastMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void BroadcastMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* BroadcastMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* BroadcastMessage::release_content() {
  // @@protoc_insertion_point(field_release:UserProto.BroadcastMessage.content)
  return _impl_.content_.Release();
}
inline void BroadcastMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.BroadcastMessage.content)
}

// -------------------------------------------------------------------

// Message

// .UserProto.MessageType message_type = 1;
inline void Message::clear_message_type() {
  _impl_.message_type_ = 0;
}
inline ::UserProto::MessageType Message::_internal_message_type() const {
  return static_cast< ::UserProto::MessageType >(_impl_.message_type_);
}
inline ::UserProto::MessageType Message::message_type() const {
  // @@protoc_insertion_point(field_get:UserProto.Message.message_type)
  return _internal_message_type();
}
inline void Message::_internal_set_message_type(::UserProto::MessageType value) {
  
  _impl_.message_type_ = value;
}
inline void Message::set_message_type(::UserProto::MessageType value) {
  _internal_set_message_type(value);
  // @@protoc_insertion_point(field_set:UserProto.Message.message_type)
}

// .UserProto.Sender sender = 2;
inline bool Message::_internal_has_sender() const {
  return this != internal_default_instance() && _impl_.sender_ != nullptr;
}
inline bool Message::has_sender() const {
  return _internal_has_sender();
}
inline void Message::clear_sender() {
  if (GetArenaForAllocation() == nullptr && _impl_.sender_ != nullptr) {
    delete _impl_.sender_;
  }
  _impl_.sender_ = nullptr;
}
inline const ::UserProto::Sender& Message::_internal_sender() const {
  const ::UserProto::Sender* p = _impl_.sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Sender&>(
      ::UserProto::_Sender_default_instance_);
}
inline const ::UserProto::Sender& Message::sender() const {
  // @@protoc_insertion_point(field_get:UserProto.Message.sender)
  return _internal_sender();
}
inline void Message::unsafe_arena_set_allocated_sender(
    ::UserProto::Sender* sender) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_);
  }
  _impl_.sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.Message.sender)
}
inline ::UserProto::Sender* Message::release_sender() {
  
  ::UserProto::Sender* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Sender* Message::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:UserProto.Message.sender)
  
  ::UserProto::Sender* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
  return temp;
}
inline ::UserProto::Sender* Message::_internal_mutable_sender() {
  
  if (_impl_.sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Sender>(GetArenaForAllocation());
    _impl_.sender_ = p;
  }
  return _impl_.sender_;
}
inline ::UserProto::Sender* Message::mutable_sender() {
  ::UserProto::Sender* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:UserProto.Message.sender)
  return _msg;
}
inline void Message::set_allocated_sender(::UserProto::Sender* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sender);
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:UserProto.Message.sender)
}

// .UserProto.Receiver receiver = 3;
inline bool Message::_internal_has_receiver() const {
  return this != internal_default_instance() && _impl_.receiver_ != nullptr;
}
inline bool Message::has_receiver() const {
  return _internal_has_receiver();
}
inline void Message::clear_receiver() {
  if (GetArenaForAllocation() == nullptr && _impl_.receiver_ != nullptr) {
    delete _impl_.receiver_;
  }
  _impl_.receiver_ = nullptr;
}
inline const ::UserProto::Receiver& Message::_internal_receiver() const {
  const ::UserProto::Receiver* p = _impl_.receiver_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Receiver&>(
      ::UserProto::_Receiver_default_instance_);
}
inline const ::UserProto::Receiver& Message::receiver() const {
  // @@protoc_insertion_point(field_get:UserProto.Message.receiver)
  return _internal_receiver();
}
inline void Message::unsafe_arena_set_allocated_receiver(
    ::UserProto::Receiver* receiver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiver_);
  }
  _impl_.receiver_ = receiver;
  if (receiver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.Message.receiver)
}
inline ::UserProto::Receiver* Message::release_receiver() {
  
  ::UserProto::Receiver* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Receiver* Message::unsafe_arena_release_receiver() {
  // @@protoc_insertion_point(field_release:UserProto.Message.receiver)
  
  ::UserProto::Receiver* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
  return temp;
}
inline ::UserProto::Receiver* Message::_internal_mutable_receiver() {
  
  if (_impl_.receiver_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Receiver>(GetArenaForAllocation());
    _impl_.receiver_ = p;
  }
  return _impl_.receiver_;
}
inline ::UserProto::Receiver* Message::mutable_receiver() {
  ::UserProto::Receiver* _msg = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:UserProto.Message.receiver)
  return _msg;
}
inline void Message::set_allocated_receiver(::UserProto::Receiver* receiver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.receiver_;
  }
  if (receiver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receiver);
    if (message_arena != submessage_arena) {
      receiver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.receiver_ = receiver;
  // @@protoc_insertion_point(field_set_allocated:UserProto.Message.receiver)
}

// string time = 4;
inline void Message::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& Message::time() const {
  // @@protoc_insertion_point(field_get:UserProto.Message.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Message.time)
}
inline std::string* Message::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:UserProto.Message.time)
  return _s;
}
inline const std::string& Message::_internal_time() const {
  return _impl_.time_.Get();
}
inline void Message::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_time() {
  // @@protoc_insertion_point(field_release:UserProto.Message.time)
  return _impl_.time_.Release();
}
inline void Message::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Message.time)
}

// string content = 5;
inline void Message::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& Message::content() const {
  // @@protoc_insertion_point(field_get:UserProto.Message.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Message::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Message.content)
}
inline std::string* Message::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:UserProto.Message.content)
  return _s;
}
inline const std::string& Message::_internal_content() const {
  return _impl_.content_.Get();
}
inline void Message::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* Message::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* Message::release_content() {
  // @@protoc_insertion_point(field_release:UserProto.Message.content)
  return _impl_.content_.Release();
}
inline void Message::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Message.content)
}

// -------------------------------------------------------------------

// Sender

// int32 user_id = 1;
inline void Sender::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t Sender::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t Sender::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.Sender.user_id)
  return _internal_user_id();
}
inline void Sender::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void Sender::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.Sender.user_id)
}

// bytes user_name = 2;
inline void Sender::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& Sender::user_name() const {
  // @@protoc_insertion_point(field_get:UserProto.Sender.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sender::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Sender.user_name)
}
inline std::string* Sender::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:UserProto.Sender.user_name)
  return _s;
}
inline const std::string& Sender::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void Sender::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Sender::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Sender::release_user_name() {
  // @@protoc_insertion_point(field_release:UserProto.Sender.user_name)
  return _impl_.user_name_.Release();
}
inline void Sender::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Sender.user_name)
}

// int32 group_id = 3;
inline void Sender::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t Sender::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t Sender::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.Sender.group_id)
  return _internal_group_id();
}
inline void Sender::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void Sender::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.Sender.group_id)
}

// bytes group_name = 4;
inline void Sender::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
}
inline const std::string& Sender::group_name() const {
  // @@protoc_insertion_point(field_get:UserProto.Sender.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Sender::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Sender.group_name)
}
inline std::string* Sender::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:UserProto.Sender.group_name)
  return _s;
}
inline const std::string& Sender::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void Sender::_internal_set_group_name(const std::string& value) {
  
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Sender::_internal_mutable_group_name() {
  
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Sender::release_group_name() {
  // @@protoc_insertion_point(field_release:UserProto.Sender.group_name)
  return _impl_.group_name_.Release();
}
inline void Sender::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Sender.group_name)
}

// -------------------------------------------------------------------

// Receiver

// int32 user_id = 1;
inline void Receiver::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t Receiver::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t Receiver::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.Receiver.user_id)
  return _internal_user_id();
}
inline void Receiver::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void Receiver::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.Receiver.user_id)
}

// bytes user_name = 2;
inline void Receiver::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& Receiver::user_name() const {
  // @@protoc_insertion_point(field_get:UserProto.Receiver.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Receiver::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Receiver.user_name)
}
inline std::string* Receiver::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:UserProto.Receiver.user_name)
  return _s;
}
inline const std::string& Receiver::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void Receiver::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Receiver::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Receiver::release_user_name() {
  // @@protoc_insertion_point(field_release:UserProto.Receiver.user_name)
  return _impl_.user_name_.Release();
}
inline void Receiver::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Receiver.user_name)
}

// int32 group_id = 3;
inline void Receiver::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t Receiver::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t Receiver::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.Receiver.group_id)
  return _internal_group_id();
}
inline void Receiver::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void Receiver::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.Receiver.group_id)
}

// bytes group_name = 4;
inline void Receiver::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
}
inline const std::string& Receiver::group_name() const {
  // @@protoc_insertion_point(field_get:UserProto.Receiver.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Receiver::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.Receiver.group_name)
}
inline std::string* Receiver::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:UserProto.Receiver.group_name)
  return _s;
}
inline const std::string& Receiver::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void Receiver::_internal_set_group_name(const std::string& value) {
  
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* Receiver::_internal_mutable_group_name() {
  
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* Receiver::release_group_name() {
  // @@protoc_insertion_point(field_release:UserProto.Receiver.group_name)
  return _impl_.group_name_.Release();
}
inline void Receiver::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.Receiver.group_name)
}

// -------------------------------------------------------------------

// GroupMessage

// .UserProto.GroupUserList group_user_list = 1;
inline bool GroupMessage::_internal_has_group_user_list() const {
  return this != internal_default_instance() && _impl_.group_user_list_ != nullptr;
}
inline bool GroupMessage::has_group_user_list() const {
  return _internal_has_group_user_list();
}
inline void GroupMessage::clear_group_user_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_user_list_ != nullptr) {
    delete _impl_.group_user_list_;
  }
  _impl_.group_user_list_ = nullptr;
}
inline const ::UserProto::GroupUserList& GroupMessage::_internal_group_user_list() const {
  const ::UserProto::GroupUserList* p = _impl_.group_user_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::GroupUserList&>(
      ::UserProto::_GroupUserList_default_instance_);
}
inline const ::UserProto::GroupUserList& GroupMessage::group_user_list() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupMessage.group_user_list)
  return _internal_group_user_list();
}
inline void GroupMessage::unsafe_arena_set_allocated_group_user_list(
    ::UserProto::GroupUserList* group_user_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_user_list_);
  }
  _impl_.group_user_list_ = group_user_list;
  if (group_user_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.GroupMessage.group_user_list)
}
inline ::UserProto::GroupUserList* GroupMessage::release_group_user_list() {
  
  ::UserProto::GroupUserList* temp = _impl_.group_user_list_;
  _impl_.group_user_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::GroupUserList* GroupMessage::unsafe_arena_release_group_user_list() {
  // @@protoc_insertion_point(field_release:UserProto.GroupMessage.group_user_list)
  
  ::UserProto::GroupUserList* temp = _impl_.group_user_list_;
  _impl_.group_user_list_ = nullptr;
  return temp;
}
inline ::UserProto::GroupUserList* GroupMessage::_internal_mutable_group_user_list() {
  
  if (_impl_.group_user_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::GroupUserList>(GetArenaForAllocation());
    _impl_.group_user_list_ = p;
  }
  return _impl_.group_user_list_;
}
inline ::UserProto::GroupUserList* GroupMessage::mutable_group_user_list() {
  ::UserProto::GroupUserList* _msg = _internal_mutable_group_user_list();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupMessage.group_user_list)
  return _msg;
}
inline void GroupMessage::set_allocated_group_user_list(::UserProto::GroupUserList* group_user_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_user_list_;
  }
  if (group_user_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_user_list);
    if (message_arena != submessage_arena) {
      group_user_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_user_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_user_list_ = group_user_list;
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupMessage.group_user_list)
}

// bytes content = 2;
inline void GroupMessage::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& GroupMessage::content() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupMessage.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupMessage::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.GroupMessage.content)
}
inline std::string* GroupMessage::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupMessage.content)
  return _s;
}
inline const std::string& GroupMessage::_internal_content() const {
  return _impl_.content_.Get();
}
inline void GroupMessage::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupMessage::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupMessage::release_content() {
  // @@protoc_insertion_point(field_release:UserProto.GroupMessage.content)
  return _impl_.content_.Release();
}
inline void GroupMessage::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupMessage.content)
}

// -------------------------------------------------------------------

// OfflineMessageList

// repeated .UserProto.Message messages = 1;
inline int OfflineMessageList::_internal_messages_size() const {
  return _impl_.messages_.size();
}
inline int OfflineMessageList::messages_size() const {
  return _internal_messages_size();
}
inline void OfflineMessageList::clear_messages() {
  _impl_.messages_.Clear();
}
inline ::UserProto::Message* OfflineMessageList::mutable_messages(int index) {
  // @@protoc_insertion_point(field_mutable:UserProto.OfflineMessageList.messages)
  return _impl_.messages_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Message >*
OfflineMessageList::mutable_messages() {
  // @@protoc_insertion_point(field_mutable_list:UserProto.OfflineMessageList.messages)
  return &_impl_.messages_;
}
inline const ::UserProto::Message& OfflineMessageList::_internal_messages(int index) const {
  return _impl_.messages_.Get(index);
}
inline const ::UserProto::Message& OfflineMessageList::messages(int index) const {
  // @@protoc_insertion_point(field_get:UserProto.OfflineMessageList.messages)
  return _internal_messages(index);
}
inline ::UserProto::Message* OfflineMessageList::_internal_add_messages() {
  return _impl_.messages_.Add();
}
inline ::UserProto::Message* OfflineMessageList::add_messages() {
  ::UserProto::Message* _add = _internal_add_messages();
  // @@protoc_insertion_point(field_add:UserProto.OfflineMessageList.messages)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::UserProto::Message >&
OfflineMessageList::messages() const {
  // @@protoc_insertion_point(field_list:UserProto.OfflineMessageList.messages)
  return _impl_.messages_;
}

// -------------------------------------------------------------------

// LoginRequest

// int32 user_id = 1;
inline void LoginRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t LoginRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t LoginRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.LoginRequest.user_id)
  return _internal_user_id();
}
inline void LoginRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void LoginRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.LoginRequest.user_id)
}

// bytes user_password = 2;
inline void LoginRequest::clear_user_password() {
  _impl_.user_password_.ClearToEmpty();
}
inline const std::string& LoginRequest::user_password() const {
  // @@protoc_insertion_point(field_get:UserProto.LoginRequest.user_password)
  return _internal_user_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LoginRequest::set_user_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.LoginRequest.user_password)
}
inline std::string* LoginRequest::mutable_user_password() {
  std::string* _s = _internal_mutable_user_password();
  // @@protoc_insertion_point(field_mutable:UserProto.LoginRequest.user_password)
  return _s;
}
inline const std::string& LoginRequest::_internal_user_password() const {
  return _impl_.user_password_.Get();
}
inline void LoginRequest::_internal_set_user_password(const std::string& value) {
  
  _impl_.user_password_.Set(value, GetArenaForAllocation());
}
inline std::string* LoginRequest::_internal_mutable_user_password() {
  
  return _impl_.user_password_.Mutable(GetArenaForAllocation());
}
inline std::string* LoginRequest::release_user_password() {
  // @@protoc_insertion_point(field_release:UserProto.LoginRequest.user_password)
  return _impl_.user_password_.Release();
}
inline void LoginRequest::set_allocated_user_password(std::string* user_password) {
  if (user_password != nullptr) {
    
  } else {
    
  }
  _impl_.user_password_.SetAllocated(user_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_password_.IsDefault()) {
    _impl_.user_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.LoginRequest.user_password)
}

// -------------------------------------------------------------------

// LoginResponse

// int32 error_code = 1;
inline void LoginResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t LoginResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t LoginResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.LoginResponse.error_code)
  return _internal_error_code();
}
inline void LoginResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void LoginResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.LoginResponse.error_code)
}

// .UserProto.User user = 2;
inline bool LoginResponse::_internal_has_user() const {
  return this != internal_default_instance() && _impl_.user_ != nullptr;
}
inline bool LoginResponse::has_user() const {
  return _internal_has_user();
}
inline void LoginResponse::clear_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.user_ != nullptr) {
    delete _impl_.user_;
  }
  _impl_.user_ = nullptr;
}
inline const ::UserProto::User& LoginResponse::_internal_user() const {
  const ::UserProto::User* p = _impl_.user_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::User&>(
      ::UserProto::_User_default_instance_);
}
inline const ::UserProto::User& LoginResponse::user() const {
  // @@protoc_insertion_point(field_get:UserProto.LoginResponse.user)
  return _internal_user();
}
inline void LoginResponse::unsafe_arena_set_allocated_user(
    ::UserProto::User* user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.user_);
  }
  _impl_.user_ = user;
  if (user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.LoginResponse.user)
}
inline ::UserProto::User* LoginResponse::release_user() {
  
  ::UserProto::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::User* LoginResponse::unsafe_arena_release_user() {
  // @@protoc_insertion_point(field_release:UserProto.LoginResponse.user)
  
  ::UserProto::User* temp = _impl_.user_;
  _impl_.user_ = nullptr;
  return temp;
}
inline ::UserProto::User* LoginResponse::_internal_mutable_user() {
  
  if (_impl_.user_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::User>(GetArenaForAllocation());
    _impl_.user_ = p;
  }
  return _impl_.user_;
}
inline ::UserProto::User* LoginResponse::mutable_user() {
  ::UserProto::User* _msg = _internal_mutable_user();
  // @@protoc_insertion_point(field_mutable:UserProto.LoginResponse.user)
  return _msg;
}
inline void LoginResponse::set_allocated_user(::UserProto::User* user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.user_;
  }
  if (user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(user);
    if (message_arena != submessage_arena) {
      user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.user_ = user;
  // @@protoc_insertion_point(field_set_allocated:UserProto.LoginResponse.user)
}

// .UserProto.FriendList friend_list = 3;
inline bool LoginResponse::_internal_has_friend_list() const {
  return this != internal_default_instance() && _impl_.friend_list_ != nullptr;
}
inline bool LoginResponse::has_friend_list() const {
  return _internal_has_friend_list();
}
inline void LoginResponse::clear_friend_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.friend_list_ != nullptr) {
    delete _impl_.friend_list_;
  }
  _impl_.friend_list_ = nullptr;
}
inline const ::UserProto::FriendList& LoginResponse::_internal_friend_list() const {
  const ::UserProto::FriendList* p = _impl_.friend_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::FriendList&>(
      ::UserProto::_FriendList_default_instance_);
}
inline const ::UserProto::FriendList& LoginResponse::friend_list() const {
  // @@protoc_insertion_point(field_get:UserProto.LoginResponse.friend_list)
  return _internal_friend_list();
}
inline void LoginResponse::unsafe_arena_set_allocated_friend_list(
    ::UserProto::FriendList* friend_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_list_);
  }
  _impl_.friend_list_ = friend_list;
  if (friend_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.LoginResponse.friend_list)
}
inline ::UserProto::FriendList* LoginResponse::release_friend_list() {
  
  ::UserProto::FriendList* temp = _impl_.friend_list_;
  _impl_.friend_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::FriendList* LoginResponse::unsafe_arena_release_friend_list() {
  // @@protoc_insertion_point(field_release:UserProto.LoginResponse.friend_list)
  
  ::UserProto::FriendList* temp = _impl_.friend_list_;
  _impl_.friend_list_ = nullptr;
  return temp;
}
inline ::UserProto::FriendList* LoginResponse::_internal_mutable_friend_list() {
  
  if (_impl_.friend_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::FriendList>(GetArenaForAllocation());
    _impl_.friend_list_ = p;
  }
  return _impl_.friend_list_;
}
inline ::UserProto::FriendList* LoginResponse::mutable_friend_list() {
  ::UserProto::FriendList* _msg = _internal_mutable_friend_list();
  // @@protoc_insertion_point(field_mutable:UserProto.LoginResponse.friend_list)
  return _msg;
}
inline void LoginResponse::set_allocated_friend_list(::UserProto::FriendList* friend_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.friend_list_;
  }
  if (friend_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_list);
    if (message_arena != submessage_arena) {
      friend_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friend_list_ = friend_list;
  // @@protoc_insertion_point(field_set_allocated:UserProto.LoginResponse.friend_list)
}

// .UserProto.GroupList group_list = 4;
inline bool LoginResponse::_internal_has_group_list() const {
  return this != internal_default_instance() && _impl_.group_list_ != nullptr;
}
inline bool LoginResponse::has_group_list() const {
  return _internal_has_group_list();
}
inline void LoginResponse::clear_group_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_list_ != nullptr) {
    delete _impl_.group_list_;
  }
  _impl_.group_list_ = nullptr;
}
inline const ::UserProto::GroupList& LoginResponse::_internal_group_list() const {
  const ::UserProto::GroupList* p = _impl_.group_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::GroupList&>(
      ::UserProto::_GroupList_default_instance_);
}
inline const ::UserProto::GroupList& LoginResponse::group_list() const {
  // @@protoc_insertion_point(field_get:UserProto.LoginResponse.group_list)
  return _internal_group_list();
}
inline void LoginResponse::unsafe_arena_set_allocated_group_list(
    ::UserProto::GroupList* group_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_list_);
  }
  _impl_.group_list_ = group_list;
  if (group_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.LoginResponse.group_list)
}
inline ::UserProto::GroupList* LoginResponse::release_group_list() {
  
  ::UserProto::GroupList* temp = _impl_.group_list_;
  _impl_.group_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::GroupList* LoginResponse::unsafe_arena_release_group_list() {
  // @@protoc_insertion_point(field_release:UserProto.LoginResponse.group_list)
  
  ::UserProto::GroupList* temp = _impl_.group_list_;
  _impl_.group_list_ = nullptr;
  return temp;
}
inline ::UserProto::GroupList* LoginResponse::_internal_mutable_group_list() {
  
  if (_impl_.group_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::GroupList>(GetArenaForAllocation());
    _impl_.group_list_ = p;
  }
  return _impl_.group_list_;
}
inline ::UserProto::GroupList* LoginResponse::mutable_group_list() {
  ::UserProto::GroupList* _msg = _internal_mutable_group_list();
  // @@protoc_insertion_point(field_mutable:UserProto.LoginResponse.group_list)
  return _msg;
}
inline void LoginResponse::set_allocated_group_list(::UserProto::GroupList* group_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_list_;
  }
  if (group_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group_list);
    if (message_arena != submessage_arena) {
      group_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_list_ = group_list;
  // @@protoc_insertion_point(field_set_allocated:UserProto.LoginResponse.group_list)
}

// .UserProto.OfflineMessageList offline_message_list = 5;
inline bool LoginResponse::_internal_has_offline_message_list() const {
  return this != internal_default_instance() && _impl_.offline_message_list_ != nullptr;
}
inline bool LoginResponse::has_offline_message_list() const {
  return _internal_has_offline_message_list();
}
inline void LoginResponse::clear_offline_message_list() {
  if (GetArenaForAllocation() == nullptr && _impl_.offline_message_list_ != nullptr) {
    delete _impl_.offline_message_list_;
  }
  _impl_.offline_message_list_ = nullptr;
}
inline const ::UserProto::OfflineMessageList& LoginResponse::_internal_offline_message_list() const {
  const ::UserProto::OfflineMessageList* p = _impl_.offline_message_list_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::OfflineMessageList&>(
      ::UserProto::_OfflineMessageList_default_instance_);
}
inline const ::UserProto::OfflineMessageList& LoginResponse::offline_message_list() const {
  // @@protoc_insertion_point(field_get:UserProto.LoginResponse.offline_message_list)
  return _internal_offline_message_list();
}
inline void LoginResponse::unsafe_arena_set_allocated_offline_message_list(
    ::UserProto::OfflineMessageList* offline_message_list) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.offline_message_list_);
  }
  _impl_.offline_message_list_ = offline_message_list;
  if (offline_message_list) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.LoginResponse.offline_message_list)
}
inline ::UserProto::OfflineMessageList* LoginResponse::release_offline_message_list() {
  
  ::UserProto::OfflineMessageList* temp = _impl_.offline_message_list_;
  _impl_.offline_message_list_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::OfflineMessageList* LoginResponse::unsafe_arena_release_offline_message_list() {
  // @@protoc_insertion_point(field_release:UserProto.LoginResponse.offline_message_list)
  
  ::UserProto::OfflineMessageList* temp = _impl_.offline_message_list_;
  _impl_.offline_message_list_ = nullptr;
  return temp;
}
inline ::UserProto::OfflineMessageList* LoginResponse::_internal_mutable_offline_message_list() {
  
  if (_impl_.offline_message_list_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::OfflineMessageList>(GetArenaForAllocation());
    _impl_.offline_message_list_ = p;
  }
  return _impl_.offline_message_list_;
}
inline ::UserProto::OfflineMessageList* LoginResponse::mutable_offline_message_list() {
  ::UserProto::OfflineMessageList* _msg = _internal_mutable_offline_message_list();
  // @@protoc_insertion_point(field_mutable:UserProto.LoginResponse.offline_message_list)
  return _msg;
}
inline void LoginResponse::set_allocated_offline_message_list(::UserProto::OfflineMessageList* offline_message_list) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.offline_message_list_;
  }
  if (offline_message_list) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(offline_message_list);
    if (message_arena != submessage_arena) {
      offline_message_list = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, offline_message_list, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.offline_message_list_ = offline_message_list;
  // @@protoc_insertion_point(field_set_allocated:UserProto.LoginResponse.offline_message_list)
}

// -------------------------------------------------------------------

// LogoutRequest

// int32 user_id = 1;
inline void LogoutRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t LogoutRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t LogoutRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.LogoutRequest.user_id)
  return _internal_user_id();
}
inline void LogoutRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void LogoutRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.LogoutRequest.user_id)
}

// -------------------------------------------------------------------

// LogoutResponse

// int32 error_code = 1;
inline void LogoutResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t LogoutResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t LogoutResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.LogoutResponse.error_code)
  return _internal_error_code();
}
inline void LogoutResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void LogoutResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.LogoutResponse.error_code)
}

// -------------------------------------------------------------------

// RegisterRequest

// bytes user_name = 2;
inline void RegisterRequest::clear_user_name() {
  _impl_.user_name_.ClearToEmpty();
}
inline const std::string& RegisterRequest::user_name() const {
  // @@protoc_insertion_point(field_get:UserProto.RegisterRequest.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.RegisterRequest.user_name)
}
inline std::string* RegisterRequest::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:UserProto.RegisterRequest.user_name)
  return _s;
}
inline const std::string& RegisterRequest::_internal_user_name() const {
  return _impl_.user_name_.Get();
}
inline void RegisterRequest::_internal_set_user_name(const std::string& value) {
  
  _impl_.user_name_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_user_name() {
  
  return _impl_.user_name_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_user_name() {
  // @@protoc_insertion_point(field_release:UserProto.RegisterRequest.user_name)
  return _impl_.user_name_.Release();
}
inline void RegisterRequest::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  _impl_.user_name_.SetAllocated(user_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_name_.IsDefault()) {
    _impl_.user_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.RegisterRequest.user_name)
}

// bytes user_password = 3;
inline void RegisterRequest::clear_user_password() {
  _impl_.user_password_.ClearToEmpty();
}
inline const std::string& RegisterRequest::user_password() const {
  // @@protoc_insertion_point(field_get:UserProto.RegisterRequest.user_password)
  return _internal_user_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegisterRequest::set_user_password(ArgT0&& arg0, ArgT... args) {
 
 _impl_.user_password_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.RegisterRequest.user_password)
}
inline std::string* RegisterRequest::mutable_user_password() {
  std::string* _s = _internal_mutable_user_password();
  // @@protoc_insertion_point(field_mutable:UserProto.RegisterRequest.user_password)
  return _s;
}
inline const std::string& RegisterRequest::_internal_user_password() const {
  return _impl_.user_password_.Get();
}
inline void RegisterRequest::_internal_set_user_password(const std::string& value) {
  
  _impl_.user_password_.Set(value, GetArenaForAllocation());
}
inline std::string* RegisterRequest::_internal_mutable_user_password() {
  
  return _impl_.user_password_.Mutable(GetArenaForAllocation());
}
inline std::string* RegisterRequest::release_user_password() {
  // @@protoc_insertion_point(field_release:UserProto.RegisterRequest.user_password)
  return _impl_.user_password_.Release();
}
inline void RegisterRequest::set_allocated_user_password(std::string* user_password) {
  if (user_password != nullptr) {
    
  } else {
    
  }
  _impl_.user_password_.SetAllocated(user_password, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.user_password_.IsDefault()) {
    _impl_.user_password_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.RegisterRequest.user_password)
}

// -------------------------------------------------------------------

// RegisterResponse

// int32 error_code = 1;
inline void RegisterResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t RegisterResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t RegisterResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.RegisterResponse.error_code)
  return _internal_error_code();
}
inline void RegisterResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void RegisterResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.RegisterResponse.error_code)
}

// int32 user_id = 2;
inline void RegisterResponse::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t RegisterResponse::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t RegisterResponse::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.RegisterResponse.user_id)
  return _internal_user_id();
}
inline void RegisterResponse::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void RegisterResponse::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.RegisterResponse.user_id)
}

// -------------------------------------------------------------------

// AddFriendRequest

// int32 user_id = 1;
inline void AddFriendRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t AddFriendRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t AddFriendRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.AddFriendRequest.user_id)
  return _internal_user_id();
}
inline void AddFriendRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void AddFriendRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.AddFriendRequest.user_id)
}

// int32 frined_id = 2;
inline void AddFriendRequest::clear_frined_id() {
  _impl_.frined_id_ = 0;
}
inline int32_t AddFriendRequest::_internal_frined_id() const {
  return _impl_.frined_id_;
}
inline int32_t AddFriendRequest::frined_id() const {
  // @@protoc_insertion_point(field_get:UserProto.AddFriendRequest.frined_id)
  return _internal_frined_id();
}
inline void AddFriendRequest::_internal_set_frined_id(int32_t value) {
  
  _impl_.frined_id_ = value;
}
inline void AddFriendRequest::set_frined_id(int32_t value) {
  _internal_set_frined_id(value);
  // @@protoc_insertion_point(field_set:UserProto.AddFriendRequest.frined_id)
}

// -------------------------------------------------------------------

// AddFriendResponse

// int32 error_code = 1;
inline void AddFriendResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t AddFriendResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t AddFriendResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.AddFriendResponse.error_code)
  return _internal_error_code();
}
inline void AddFriendResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void AddFriendResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.AddFriendResponse.error_code)
}

// .UserProto.FriendUser friend_user = 2;
inline bool AddFriendResponse::_internal_has_friend_user() const {
  return this != internal_default_instance() && _impl_.friend_user_ != nullptr;
}
inline bool AddFriendResponse::has_friend_user() const {
  return _internal_has_friend_user();
}
inline void AddFriendResponse::clear_friend_user() {
  if (GetArenaForAllocation() == nullptr && _impl_.friend_user_ != nullptr) {
    delete _impl_.friend_user_;
  }
  _impl_.friend_user_ = nullptr;
}
inline const ::UserProto::FriendUser& AddFriendResponse::_internal_friend_user() const {
  const ::UserProto::FriendUser* p = _impl_.friend_user_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::FriendUser&>(
      ::UserProto::_FriendUser_default_instance_);
}
inline const ::UserProto::FriendUser& AddFriendResponse::friend_user() const {
  // @@protoc_insertion_point(field_get:UserProto.AddFriendResponse.friend_user)
  return _internal_friend_user();
}
inline void AddFriendResponse::unsafe_arena_set_allocated_friend_user(
    ::UserProto::FriendUser* friend_user) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.friend_user_);
  }
  _impl_.friend_user_ = friend_user;
  if (friend_user) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.AddFriendResponse.friend_user)
}
inline ::UserProto::FriendUser* AddFriendResponse::release_friend_user() {
  
  ::UserProto::FriendUser* temp = _impl_.friend_user_;
  _impl_.friend_user_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::FriendUser* AddFriendResponse::unsafe_arena_release_friend_user() {
  // @@protoc_insertion_point(field_release:UserProto.AddFriendResponse.friend_user)
  
  ::UserProto::FriendUser* temp = _impl_.friend_user_;
  _impl_.friend_user_ = nullptr;
  return temp;
}
inline ::UserProto::FriendUser* AddFriendResponse::_internal_mutable_friend_user() {
  
  if (_impl_.friend_user_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::FriendUser>(GetArenaForAllocation());
    _impl_.friend_user_ = p;
  }
  return _impl_.friend_user_;
}
inline ::UserProto::FriendUser* AddFriendResponse::mutable_friend_user() {
  ::UserProto::FriendUser* _msg = _internal_mutable_friend_user();
  // @@protoc_insertion_point(field_mutable:UserProto.AddFriendResponse.friend_user)
  return _msg;
}
inline void AddFriendResponse::set_allocated_friend_user(::UserProto::FriendUser* friend_user) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.friend_user_;
  }
  if (friend_user) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(friend_user);
    if (message_arena != submessage_arena) {
      friend_user = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, friend_user, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.friend_user_ = friend_user;
  // @@protoc_insertion_point(field_set_allocated:UserProto.AddFriendResponse.friend_user)
}

// -------------------------------------------------------------------

// DeleteFriendRequest

// int32 user_id = 1;
inline void DeleteFriendRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t DeleteFriendRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t DeleteFriendRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteFriendRequest.user_id)
  return _internal_user_id();
}
inline void DeleteFriendRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void DeleteFriendRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteFriendRequest.user_id)
}

// int32 frined_id = 2;
inline void DeleteFriendRequest::clear_frined_id() {
  _impl_.frined_id_ = 0;
}
inline int32_t DeleteFriendRequest::_internal_frined_id() const {
  return _impl_.frined_id_;
}
inline int32_t DeleteFriendRequest::frined_id() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteFriendRequest.frined_id)
  return _internal_frined_id();
}
inline void DeleteFriendRequest::_internal_set_frined_id(int32_t value) {
  
  _impl_.frined_id_ = value;
}
inline void DeleteFriendRequest::set_frined_id(int32_t value) {
  _internal_set_frined_id(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteFriendRequest.frined_id)
}

// -------------------------------------------------------------------

// DeleteFriendResponse

// int32 error_code = 1;
inline void DeleteFriendResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t DeleteFriendResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t DeleteFriendResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteFriendResponse.error_code)
  return _internal_error_code();
}
inline void DeleteFriendResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void DeleteFriendResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteFriendResponse.error_code)
}

// int32 frined_id = 2;
inline void DeleteFriendResponse::clear_frined_id() {
  _impl_.frined_id_ = 0;
}
inline int32_t DeleteFriendResponse::_internal_frined_id() const {
  return _impl_.frined_id_;
}
inline int32_t DeleteFriendResponse::frined_id() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteFriendResponse.frined_id)
  return _internal_frined_id();
}
inline void DeleteFriendResponse::_internal_set_frined_id(int32_t value) {
  
  _impl_.frined_id_ = value;
}
inline void DeleteFriendResponse::set_frined_id(int32_t value) {
  _internal_set_frined_id(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteFriendResponse.frined_id)
}

// -------------------------------------------------------------------

// FriendChatRequest

// .UserProto.Sender sender = 1;
inline bool FriendChatRequest::_internal_has_sender() const {
  return this != internal_default_instance() && _impl_.sender_ != nullptr;
}
inline bool FriendChatRequest::has_sender() const {
  return _internal_has_sender();
}
inline void FriendChatRequest::clear_sender() {
  if (GetArenaForAllocation() == nullptr && _impl_.sender_ != nullptr) {
    delete _impl_.sender_;
  }
  _impl_.sender_ = nullptr;
}
inline const ::UserProto::Sender& FriendChatRequest::_internal_sender() const {
  const ::UserProto::Sender* p = _impl_.sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Sender&>(
      ::UserProto::_Sender_default_instance_);
}
inline const ::UserProto::Sender& FriendChatRequest::sender() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendChatRequest.sender)
  return _internal_sender();
}
inline void FriendChatRequest::unsafe_arena_set_allocated_sender(
    ::UserProto::Sender* sender) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_);
  }
  _impl_.sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.FriendChatRequest.sender)
}
inline ::UserProto::Sender* FriendChatRequest::release_sender() {
  
  ::UserProto::Sender* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Sender* FriendChatRequest::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:UserProto.FriendChatRequest.sender)
  
  ::UserProto::Sender* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
  return temp;
}
inline ::UserProto::Sender* FriendChatRequest::_internal_mutable_sender() {
  
  if (_impl_.sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Sender>(GetArenaForAllocation());
    _impl_.sender_ = p;
  }
  return _impl_.sender_;
}
inline ::UserProto::Sender* FriendChatRequest::mutable_sender() {
  ::UserProto::Sender* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:UserProto.FriendChatRequest.sender)
  return _msg;
}
inline void FriendChatRequest::set_allocated_sender(::UserProto::Sender* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sender);
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:UserProto.FriendChatRequest.sender)
}

// .UserProto.Receiver receiver = 2;
inline bool FriendChatRequest::_internal_has_receiver() const {
  return this != internal_default_instance() && _impl_.receiver_ != nullptr;
}
inline bool FriendChatRequest::has_receiver() const {
  return _internal_has_receiver();
}
inline void FriendChatRequest::clear_receiver() {
  if (GetArenaForAllocation() == nullptr && _impl_.receiver_ != nullptr) {
    delete _impl_.receiver_;
  }
  _impl_.receiver_ = nullptr;
}
inline const ::UserProto::Receiver& FriendChatRequest::_internal_receiver() const {
  const ::UserProto::Receiver* p = _impl_.receiver_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Receiver&>(
      ::UserProto::_Receiver_default_instance_);
}
inline const ::UserProto::Receiver& FriendChatRequest::receiver() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendChatRequest.receiver)
  return _internal_receiver();
}
inline void FriendChatRequest::unsafe_arena_set_allocated_receiver(
    ::UserProto::Receiver* receiver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiver_);
  }
  _impl_.receiver_ = receiver;
  if (receiver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.FriendChatRequest.receiver)
}
inline ::UserProto::Receiver* FriendChatRequest::release_receiver() {
  
  ::UserProto::Receiver* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Receiver* FriendChatRequest::unsafe_arena_release_receiver() {
  // @@protoc_insertion_point(field_release:UserProto.FriendChatRequest.receiver)
  
  ::UserProto::Receiver* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
  return temp;
}
inline ::UserProto::Receiver* FriendChatRequest::_internal_mutable_receiver() {
  
  if (_impl_.receiver_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Receiver>(GetArenaForAllocation());
    _impl_.receiver_ = p;
  }
  return _impl_.receiver_;
}
inline ::UserProto::Receiver* FriendChatRequest::mutable_receiver() {
  ::UserProto::Receiver* _msg = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:UserProto.FriendChatRequest.receiver)
  return _msg;
}
inline void FriendChatRequest::set_allocated_receiver(::UserProto::Receiver* receiver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.receiver_;
  }
  if (receiver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receiver);
    if (message_arena != submessage_arena) {
      receiver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.receiver_ = receiver;
  // @@protoc_insertion_point(field_set_allocated:UserProto.FriendChatRequest.receiver)
}

// string content = 3;
inline void FriendChatRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& FriendChatRequest::content() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendChatRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendChatRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.FriendChatRequest.content)
}
inline std::string* FriendChatRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:UserProto.FriendChatRequest.content)
  return _s;
}
inline const std::string& FriendChatRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void FriendChatRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendChatRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendChatRequest::release_content() {
  // @@protoc_insertion_point(field_release:UserProto.FriendChatRequest.content)
  return _impl_.content_.Release();
}
inline void FriendChatRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.FriendChatRequest.content)
}

// string time = 4;
inline void FriendChatRequest::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& FriendChatRequest::time() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendChatRequest.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FriendChatRequest::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.FriendChatRequest.time)
}
inline std::string* FriendChatRequest::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:UserProto.FriendChatRequest.time)
  return _s;
}
inline const std::string& FriendChatRequest::_internal_time() const {
  return _impl_.time_.Get();
}
inline void FriendChatRequest::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* FriendChatRequest::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* FriendChatRequest::release_time() {
  // @@protoc_insertion_point(field_release:UserProto.FriendChatRequest.time)
  return _impl_.time_.Release();
}
inline void FriendChatRequest::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.FriendChatRequest.time)
}

// -------------------------------------------------------------------

// FriendChatResponse

// int32 error_code = 1;
inline void FriendChatResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t FriendChatResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t FriendChatResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.FriendChatResponse.error_code)
  return _internal_error_code();
}
inline void FriendChatResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void FriendChatResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.FriendChatResponse.error_code)
}

// -------------------------------------------------------------------

// CreateGroupRequest

// int32 user_id = 1;
inline void CreateGroupRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t CreateGroupRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t CreateGroupRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.CreateGroupRequest.user_id)
  return _internal_user_id();
}
inline void CreateGroupRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void CreateGroupRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.CreateGroupRequest.user_id)
}

// bytes group_name = 2;
inline void CreateGroupRequest::clear_group_name() {
  _impl_.group_name_.ClearToEmpty();
}
inline const std::string& CreateGroupRequest::group_name() const {
  // @@protoc_insertion_point(field_get:UserProto.CreateGroupRequest.group_name)
  return _internal_group_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGroupRequest::set_group_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_name_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.CreateGroupRequest.group_name)
}
inline std::string* CreateGroupRequest::mutable_group_name() {
  std::string* _s = _internal_mutable_group_name();
  // @@protoc_insertion_point(field_mutable:UserProto.CreateGroupRequest.group_name)
  return _s;
}
inline const std::string& CreateGroupRequest::_internal_group_name() const {
  return _impl_.group_name_.Get();
}
inline void CreateGroupRequest::_internal_set_group_name(const std::string& value) {
  
  _impl_.group_name_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::_internal_mutable_group_name() {
  
  return _impl_.group_name_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::release_group_name() {
  // @@protoc_insertion_point(field_release:UserProto.CreateGroupRequest.group_name)
  return _impl_.group_name_.Release();
}
inline void CreateGroupRequest::set_allocated_group_name(std::string* group_name) {
  if (group_name != nullptr) {
    
  } else {
    
  }
  _impl_.group_name_.SetAllocated(group_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_name_.IsDefault()) {
    _impl_.group_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.CreateGroupRequest.group_name)
}

// bytes group_description = 3;
inline void CreateGroupRequest::clear_group_description() {
  _impl_.group_description_.ClearToEmpty();
}
inline const std::string& CreateGroupRequest::group_description() const {
  // @@protoc_insertion_point(field_get:UserProto.CreateGroupRequest.group_description)
  return _internal_group_description();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CreateGroupRequest::set_group_description(ArgT0&& arg0, ArgT... args) {
 
 _impl_.group_description_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.CreateGroupRequest.group_description)
}
inline std::string* CreateGroupRequest::mutable_group_description() {
  std::string* _s = _internal_mutable_group_description();
  // @@protoc_insertion_point(field_mutable:UserProto.CreateGroupRequest.group_description)
  return _s;
}
inline const std::string& CreateGroupRequest::_internal_group_description() const {
  return _impl_.group_description_.Get();
}
inline void CreateGroupRequest::_internal_set_group_description(const std::string& value) {
  
  _impl_.group_description_.Set(value, GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::_internal_mutable_group_description() {
  
  return _impl_.group_description_.Mutable(GetArenaForAllocation());
}
inline std::string* CreateGroupRequest::release_group_description() {
  // @@protoc_insertion_point(field_release:UserProto.CreateGroupRequest.group_description)
  return _impl_.group_description_.Release();
}
inline void CreateGroupRequest::set_allocated_group_description(std::string* group_description) {
  if (group_description != nullptr) {
    
  } else {
    
  }
  _impl_.group_description_.SetAllocated(group_description, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.group_description_.IsDefault()) {
    _impl_.group_description_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.CreateGroupRequest.group_description)
}

// -------------------------------------------------------------------

// CreateGroupResponse

// int32 error_code = 1;
inline void CreateGroupResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t CreateGroupResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t CreateGroupResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.CreateGroupResponse.error_code)
  return _internal_error_code();
}
inline void CreateGroupResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void CreateGroupResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.CreateGroupResponse.error_code)
}

// .UserProto.Group group = 2;
inline bool CreateGroupResponse::_internal_has_group() const {
  return this != internal_default_instance() && _impl_.group_ != nullptr;
}
inline bool CreateGroupResponse::has_group() const {
  return _internal_has_group();
}
inline void CreateGroupResponse::clear_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_ != nullptr) {
    delete _impl_.group_;
  }
  _impl_.group_ = nullptr;
}
inline const ::UserProto::Group& CreateGroupResponse::_internal_group() const {
  const ::UserProto::Group* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Group&>(
      ::UserProto::_Group_default_instance_);
}
inline const ::UserProto::Group& CreateGroupResponse::group() const {
  // @@protoc_insertion_point(field_get:UserProto.CreateGroupResponse.group)
  return _internal_group();
}
inline void CreateGroupResponse::unsafe_arena_set_allocated_group(
    ::UserProto::Group* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.CreateGroupResponse.group)
}
inline ::UserProto::Group* CreateGroupResponse::release_group() {
  
  ::UserProto::Group* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Group* CreateGroupResponse::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:UserProto.CreateGroupResponse.group)
  
  ::UserProto::Group* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::UserProto::Group* CreateGroupResponse::_internal_mutable_group() {
  
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Group>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::UserProto::Group* CreateGroupResponse::mutable_group() {
  ::UserProto::Group* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:UserProto.CreateGroupResponse.group)
  return _msg;
}
inline void CreateGroupResponse::set_allocated_group(::UserProto::Group* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:UserProto.CreateGroupResponse.group)
}

// -------------------------------------------------------------------

// AddGroupRequest

// int32 user_id = 1;
inline void AddGroupRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t AddGroupRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t AddGroupRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.AddGroupRequest.user_id)
  return _internal_user_id();
}
inline void AddGroupRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void AddGroupRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.AddGroupRequest.user_id)
}

// int32 group_id = 2;
inline void AddGroupRequest::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t AddGroupRequest::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t AddGroupRequest::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.AddGroupRequest.group_id)
  return _internal_group_id();
}
inline void AddGroupRequest::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void AddGroupRequest::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.AddGroupRequest.group_id)
}

// -------------------------------------------------------------------

// AddGroupResponse

// int32 error_code = 1;
inline void AddGroupResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t AddGroupResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t AddGroupResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.AddGroupResponse.error_code)
  return _internal_error_code();
}
inline void AddGroupResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void AddGroupResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.AddGroupResponse.error_code)
}

// .UserProto.Group group = 2;
inline bool AddGroupResponse::_internal_has_group() const {
  return this != internal_default_instance() && _impl_.group_ != nullptr;
}
inline bool AddGroupResponse::has_group() const {
  return _internal_has_group();
}
inline void AddGroupResponse::clear_group() {
  if (GetArenaForAllocation() == nullptr && _impl_.group_ != nullptr) {
    delete _impl_.group_;
  }
  _impl_.group_ = nullptr;
}
inline const ::UserProto::Group& AddGroupResponse::_internal_group() const {
  const ::UserProto::Group* p = _impl_.group_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Group&>(
      ::UserProto::_Group_default_instance_);
}
inline const ::UserProto::Group& AddGroupResponse::group() const {
  // @@protoc_insertion_point(field_get:UserProto.AddGroupResponse.group)
  return _internal_group();
}
inline void AddGroupResponse::unsafe_arena_set_allocated_group(
    ::UserProto::Group* group) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.group_);
  }
  _impl_.group_ = group;
  if (group) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.AddGroupResponse.group)
}
inline ::UserProto::Group* AddGroupResponse::release_group() {
  
  ::UserProto::Group* temp = _impl_.group_;
  _impl_.group_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Group* AddGroupResponse::unsafe_arena_release_group() {
  // @@protoc_insertion_point(field_release:UserProto.AddGroupResponse.group)
  
  ::UserProto::Group* temp = _impl_.group_;
  _impl_.group_ = nullptr;
  return temp;
}
inline ::UserProto::Group* AddGroupResponse::_internal_mutable_group() {
  
  if (_impl_.group_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Group>(GetArenaForAllocation());
    _impl_.group_ = p;
  }
  return _impl_.group_;
}
inline ::UserProto::Group* AddGroupResponse::mutable_group() {
  ::UserProto::Group* _msg = _internal_mutable_group();
  // @@protoc_insertion_point(field_mutable:UserProto.AddGroupResponse.group)
  return _msg;
}
inline void AddGroupResponse::set_allocated_group(::UserProto::Group* group) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.group_;
  }
  if (group) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(group);
    if (message_arena != submessage_arena) {
      group = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, group, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.group_ = group;
  // @@protoc_insertion_point(field_set_allocated:UserProto.AddGroupResponse.group)
}

// -------------------------------------------------------------------

// DeleteGroupRequest

// int32 user_id = 1;
inline void DeleteGroupRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t DeleteGroupRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t DeleteGroupRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteGroupRequest.user_id)
  return _internal_user_id();
}
inline void DeleteGroupRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void DeleteGroupRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteGroupRequest.user_id)
}

// int32 group_id = 2;
inline void DeleteGroupRequest::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t DeleteGroupRequest::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t DeleteGroupRequest::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteGroupRequest.group_id)
  return _internal_group_id();
}
inline void DeleteGroupRequest::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void DeleteGroupRequest::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteGroupRequest.group_id)
}

// -------------------------------------------------------------------

// DeleteGroupResponse

// int32 error_code = 1;
inline void DeleteGroupResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t DeleteGroupResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t DeleteGroupResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteGroupResponse.error_code)
  return _internal_error_code();
}
inline void DeleteGroupResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void DeleteGroupResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteGroupResponse.error_code)
}

// int32 group_id = 2;
inline void DeleteGroupResponse::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t DeleteGroupResponse::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t DeleteGroupResponse::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.DeleteGroupResponse.group_id)
  return _internal_group_id();
}
inline void DeleteGroupResponse::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void DeleteGroupResponse::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.DeleteGroupResponse.group_id)
}

// -------------------------------------------------------------------

// QuitGroupRequest

// int32 user_id = 1;
inline void QuitGroupRequest::clear_user_id() {
  _impl_.user_id_ = 0;
}
inline int32_t QuitGroupRequest::_internal_user_id() const {
  return _impl_.user_id_;
}
inline int32_t QuitGroupRequest::user_id() const {
  // @@protoc_insertion_point(field_get:UserProto.QuitGroupRequest.user_id)
  return _internal_user_id();
}
inline void QuitGroupRequest::_internal_set_user_id(int32_t value) {
  
  _impl_.user_id_ = value;
}
inline void QuitGroupRequest::set_user_id(int32_t value) {
  _internal_set_user_id(value);
  // @@protoc_insertion_point(field_set:UserProto.QuitGroupRequest.user_id)
}

// int32 group_id = 2;
inline void QuitGroupRequest::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t QuitGroupRequest::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t QuitGroupRequest::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.QuitGroupRequest.group_id)
  return _internal_group_id();
}
inline void QuitGroupRequest::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void QuitGroupRequest::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.QuitGroupRequest.group_id)
}

// -------------------------------------------------------------------

// QuitGroupResponse

// int32 error_code = 1;
inline void QuitGroupResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t QuitGroupResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t QuitGroupResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.QuitGroupResponse.error_code)
  return _internal_error_code();
}
inline void QuitGroupResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void QuitGroupResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.QuitGroupResponse.error_code)
}

// int32 group_id = 2;
inline void QuitGroupResponse::clear_group_id() {
  _impl_.group_id_ = 0;
}
inline int32_t QuitGroupResponse::_internal_group_id() const {
  return _impl_.group_id_;
}
inline int32_t QuitGroupResponse::group_id() const {
  // @@protoc_insertion_point(field_get:UserProto.QuitGroupResponse.group_id)
  return _internal_group_id();
}
inline void QuitGroupResponse::_internal_set_group_id(int32_t value) {
  
  _impl_.group_id_ = value;
}
inline void QuitGroupResponse::set_group_id(int32_t value) {
  _internal_set_group_id(value);
  // @@protoc_insertion_point(field_set:UserProto.QuitGroupResponse.group_id)
}

// -------------------------------------------------------------------

// GroupChatRequest

// .UserProto.Sender sender = 1;
inline bool GroupChatRequest::_internal_has_sender() const {
  return this != internal_default_instance() && _impl_.sender_ != nullptr;
}
inline bool GroupChatRequest::has_sender() const {
  return _internal_has_sender();
}
inline void GroupChatRequest::clear_sender() {
  if (GetArenaForAllocation() == nullptr && _impl_.sender_ != nullptr) {
    delete _impl_.sender_;
  }
  _impl_.sender_ = nullptr;
}
inline const ::UserProto::Sender& GroupChatRequest::_internal_sender() const {
  const ::UserProto::Sender* p = _impl_.sender_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Sender&>(
      ::UserProto::_Sender_default_instance_);
}
inline const ::UserProto::Sender& GroupChatRequest::sender() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupChatRequest.sender)
  return _internal_sender();
}
inline void GroupChatRequest::unsafe_arena_set_allocated_sender(
    ::UserProto::Sender* sender) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.sender_);
  }
  _impl_.sender_ = sender;
  if (sender) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.GroupChatRequest.sender)
}
inline ::UserProto::Sender* GroupChatRequest::release_sender() {
  
  ::UserProto::Sender* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Sender* GroupChatRequest::unsafe_arena_release_sender() {
  // @@protoc_insertion_point(field_release:UserProto.GroupChatRequest.sender)
  
  ::UserProto::Sender* temp = _impl_.sender_;
  _impl_.sender_ = nullptr;
  return temp;
}
inline ::UserProto::Sender* GroupChatRequest::_internal_mutable_sender() {
  
  if (_impl_.sender_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Sender>(GetArenaForAllocation());
    _impl_.sender_ = p;
  }
  return _impl_.sender_;
}
inline ::UserProto::Sender* GroupChatRequest::mutable_sender() {
  ::UserProto::Sender* _msg = _internal_mutable_sender();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupChatRequest.sender)
  return _msg;
}
inline void GroupChatRequest::set_allocated_sender(::UserProto::Sender* sender) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.sender_;
  }
  if (sender) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(sender);
    if (message_arena != submessage_arena) {
      sender = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sender, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.sender_ = sender;
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupChatRequest.sender)
}

// .UserProto.Receiver receiver = 2;
inline bool GroupChatRequest::_internal_has_receiver() const {
  return this != internal_default_instance() && _impl_.receiver_ != nullptr;
}
inline bool GroupChatRequest::has_receiver() const {
  return _internal_has_receiver();
}
inline void GroupChatRequest::clear_receiver() {
  if (GetArenaForAllocation() == nullptr && _impl_.receiver_ != nullptr) {
    delete _impl_.receiver_;
  }
  _impl_.receiver_ = nullptr;
}
inline const ::UserProto::Receiver& GroupChatRequest::_internal_receiver() const {
  const ::UserProto::Receiver* p = _impl_.receiver_;
  return p != nullptr ? *p : reinterpret_cast<const ::UserProto::Receiver&>(
      ::UserProto::_Receiver_default_instance_);
}
inline const ::UserProto::Receiver& GroupChatRequest::receiver() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupChatRequest.receiver)
  return _internal_receiver();
}
inline void GroupChatRequest::unsafe_arena_set_allocated_receiver(
    ::UserProto::Receiver* receiver) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.receiver_);
  }
  _impl_.receiver_ = receiver;
  if (receiver) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:UserProto.GroupChatRequest.receiver)
}
inline ::UserProto::Receiver* GroupChatRequest::release_receiver() {
  
  ::UserProto::Receiver* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::UserProto::Receiver* GroupChatRequest::unsafe_arena_release_receiver() {
  // @@protoc_insertion_point(field_release:UserProto.GroupChatRequest.receiver)
  
  ::UserProto::Receiver* temp = _impl_.receiver_;
  _impl_.receiver_ = nullptr;
  return temp;
}
inline ::UserProto::Receiver* GroupChatRequest::_internal_mutable_receiver() {
  
  if (_impl_.receiver_ == nullptr) {
    auto* p = CreateMaybeMessage<::UserProto::Receiver>(GetArenaForAllocation());
    _impl_.receiver_ = p;
  }
  return _impl_.receiver_;
}
inline ::UserProto::Receiver* GroupChatRequest::mutable_receiver() {
  ::UserProto::Receiver* _msg = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupChatRequest.receiver)
  return _msg;
}
inline void GroupChatRequest::set_allocated_receiver(::UserProto::Receiver* receiver) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.receiver_;
  }
  if (receiver) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(receiver);
    if (message_arena != submessage_arena) {
      receiver = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, receiver, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.receiver_ = receiver;
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupChatRequest.receiver)
}

// string content = 3;
inline void GroupChatRequest::clear_content() {
  _impl_.content_.ClearToEmpty();
}
inline const std::string& GroupChatRequest::content() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupChatRequest.content)
  return _internal_content();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChatRequest::set_content(ArgT0&& arg0, ArgT... args) {
 
 _impl_.content_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.GroupChatRequest.content)
}
inline std::string* GroupChatRequest::mutable_content() {
  std::string* _s = _internal_mutable_content();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupChatRequest.content)
  return _s;
}
inline const std::string& GroupChatRequest::_internal_content() const {
  return _impl_.content_.Get();
}
inline void GroupChatRequest::_internal_set_content(const std::string& value) {
  
  _impl_.content_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChatRequest::_internal_mutable_content() {
  
  return _impl_.content_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChatRequest::release_content() {
  // @@protoc_insertion_point(field_release:UserProto.GroupChatRequest.content)
  return _impl_.content_.Release();
}
inline void GroupChatRequest::set_allocated_content(std::string* content) {
  if (content != nullptr) {
    
  } else {
    
  }
  _impl_.content_.SetAllocated(content, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.content_.IsDefault()) {
    _impl_.content_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupChatRequest.content)
}

// string time = 4;
inline void GroupChatRequest::clear_time() {
  _impl_.time_.ClearToEmpty();
}
inline const std::string& GroupChatRequest::time() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupChatRequest.time)
  return _internal_time();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GroupChatRequest::set_time(ArgT0&& arg0, ArgT... args) {
 
 _impl_.time_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:UserProto.GroupChatRequest.time)
}
inline std::string* GroupChatRequest::mutable_time() {
  std::string* _s = _internal_mutable_time();
  // @@protoc_insertion_point(field_mutable:UserProto.GroupChatRequest.time)
  return _s;
}
inline const std::string& GroupChatRequest::_internal_time() const {
  return _impl_.time_.Get();
}
inline void GroupChatRequest::_internal_set_time(const std::string& value) {
  
  _impl_.time_.Set(value, GetArenaForAllocation());
}
inline std::string* GroupChatRequest::_internal_mutable_time() {
  
  return _impl_.time_.Mutable(GetArenaForAllocation());
}
inline std::string* GroupChatRequest::release_time() {
  // @@protoc_insertion_point(field_release:UserProto.GroupChatRequest.time)
  return _impl_.time_.Release();
}
inline void GroupChatRequest::set_allocated_time(std::string* time) {
  if (time != nullptr) {
    
  } else {
    
  }
  _impl_.time_.SetAllocated(time, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.time_.IsDefault()) {
    _impl_.time_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:UserProto.GroupChatRequest.time)
}

// -------------------------------------------------------------------

// GroupChatResponse

// int32 error_code = 1;
inline void GroupChatResponse::clear_error_code() {
  _impl_.error_code_ = 0;
}
inline int32_t GroupChatResponse::_internal_error_code() const {
  return _impl_.error_code_;
}
inline int32_t GroupChatResponse::error_code() const {
  // @@protoc_insertion_point(field_get:UserProto.GroupChatResponse.error_code)
  return _internal_error_code();
}
inline void GroupChatResponse::_internal_set_error_code(int32_t value) {
  
  _impl_.error_code_ = value;
}
inline void GroupChatResponse::set_error_code(int32_t value) {
  _internal_set_error_code(value);
  // @@protoc_insertion_point(field_set:UserProto.GroupChatResponse.error_code)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace UserProto

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::UserProto::MessageType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::UserProto::MessageType>() {
  return ::UserProto::MessageType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_user_2eproto
